# 第18章 性能と堅牢性

第 17 章で nvdiffrast の解剖を学びました。本章では **性能と堅牢性** を扱います。メモリレイアウトとキャッシュ（18.1）、大きなメッシュ・高解像度へのスケール（18.2）、エッジケース（クリッピング・カリング・退化）（18.3）、デバッグと可視化（18.4）、マルチ GPU・分散処理とスケーラビリティ（18.5）、そして浮動小数点の精度問題と ε（18.6）を整理します。nvdiffrast 相当の品質を維持しつつ、実運用でぶつかりやすい問題と対処を押さえます。

---

## 18.1 メモリレイアウトとキャッシュ

### 18.1.1 SoA と AoS

**SoA（Struct of Arrays）**: 頂点位置の x をまとめた配列、y をまとめた配列、z をまとめた配列、のように **成分ごと** に配列を分けるレイアウト。連続アクセスになりやすく、SIMD や GPU の coalesced アクセスと相性が良い。

**AoS（Array of Structs）**: 頂点ごとに (x, y, z, w) を一塊で持つレイアウト。直感的だが、特定の成分だけを読むときはメモリが飛び飛びになり、キャッシュ効率が落ちることがある。

ラスタライザでは、**頂点位置** を読むときは x, y, z, w をまとめて使うことが多いため、AoS でも問題ない場合がある。一方、**interpolate** で複数属性を読むとき、属性ごとに SoA にしておくと「色だけ」「法線だけ」のループが連続アクセスになり、帯域を有効に使える。実装とプロファイリングで、どちらが速いかを計測して決めるのが無難です。

### 18.1.2 キャッシュの意識

- **共有メモリ**: 同じ block が参照する三角形の頂点やエッジを、グローバルメモリから一度共有メモリにコピーし、複数回参照する。第 15 章で触れた「タイル内の三角形」のデータを block で共有するパターン。
- **局所性**: ピクセル並列で「隣接ピクセル」が隣接スレッドになるようにスレッド ID を割り当てると、フレームバッファへの書き込みが連続し、キャッシュやメモリ帯域を活かせる。
- **勾配バッファ**: backward で頂点勾配を **加算** するとき、同じ頂点に複数スレッドが書き込む。アトミック加算はキャッシュと相性が悪いが、避けられない場合は、中間バッファでスレッドごとに加算しておき、後でリダクションするなどの工夫がある（コストと実装のトレードオフ）。

---

## 18.2 大きなメッシュ・高解像度へのスケール

### 18.2.1 メッシュサイズ

頂点数・面数が増えると、次のコストが増えます。

- **頂点バッファ・面バッファ**: メモリは線形に増加。GPU メモリの制限内に収める。
- **ラスタライズ**: 三角形数に比例する処理量。三角形並列なら並列度は増えるが、深度ソートやフラグメント蓄積のコストも増える。**レベルオブディテール（LOD）** で遠くのメッシュの面数を減らす、または **タイルベース** で「タイルに含まれる三角形だけ」を扱うことでスケールさせる。
- **勾配**: 頂点勾配のバッファも頂点数に比例。アトミック加算の競合が増えると遅くなる可能性がある。

### 18.2.2 解像度

解像度 $W \times H$ が大きいと、フレームバッファ・深度バッファ・幾何バッファのサイズが $O(WH)$ で増えます。メモリと計算量の両方が増えるため、

- **マルチ解像度学習**: 初期は低解像度で学習し、徐々に解像度を上げる（第 16 章）。
- **勾配の解像度**: 逆伝播の勾配バッファも同じ解像度が必要。メモリが足りない場合は、勾配を低解像度で近似する（品質とのトレードオフ）か、バッチサイズや解像度を下げる。

大きなメッシュと高解像度を同時に要求すると、単一 GPU では限界に達するため、18.5 のマルチ GPU や分散処理が検討対象になります。

---

## 18.3 エッジケース（クリッピング・カリング・退化）

### 18.3.1 クリッピング

視錐台の外にある三角形、または視錐台をまたぐ三角形は、**クリッピング** で処理します。クリップすると新しい頂点が生じ、三角形が複数の小三角形に分割されることがあります。

- **自作での扱い**: 第 12 章で触れたように、簡易的には「完全に外の三角形はスキップ」でよい。一部だけ見える場合は、クリッピングを実装すると、はみ出した部分が正しく描画され、勾配もクリップ頂点に按分される。
- **nvdiffrast**: クリッピングを実装しており、クリップで生成された頂点にも属性を補間し、逆伝播で元の頂点に勾配を按分している。自作で同等を目指す場合は、Sutherland–Hodgman などのアルゴリズムと、勾配の按分式を実装する。

### 18.3.2 カリング

**背面カリング** では、法線がカメラを向いていない面を描画しません。オプションで「両面描画」にすると、裏側にも勾配が流れ、薄い板や内側の形状の最適化に有効です。**フラスタムカリング** は、視錐台にまったく含まれない三角形を早い段階で捨て、無駄なラスタライズを省きます。

### 18.3.3 退化三角形

面積が 0 に近い三角形（3 頂点が一直線上または同一）は、**除算**（重心座標の $2A$）で 0 や不安定な値になるため、ラスタライザに渡す前にスキップするか、内部で `abs(2A) < eps` のときはその三角形を描画しないようにする（第 12 章）。勾配は流さない（0 とする）。メッシュの前処理で退化面を除去しておくことも有効です。

---

## 18.4 デバッグと可視化（勾配・マスク・重み）

### 18.4.1 勾配の可視化

- **頂点勾配**: 各頂点への勾配のノルムを、メッシュ上で色やスケールで表示する。どの頂点が損失に敏感か、勾配が 0 の頂点（見えていない・計算が途切れている）がないかが分かる。
- **ピクセル勾配**: $\partial L / \partial I_{i,j}$ を画像として保存し、損失が効いている領域を確認する。シルエットのずれやテクスチャのずれで勾配が大きくなっているかを見る。
- **中間勾配**: $(u,v)$ の勾配や、rasterize の backward への入力勾配を、画像としてダンプする。逆伝播のどの段階でおかしくなっているかを切り分けるのに有効。

### 18.4.2 マスク・重みの可視化

- **どのピクセルにどの三角形が描かれたか**: 三角形 ID を擬似カラーで表示する。期待した三角形が描かれているか、境界がおかしくないかを確認する。
- **重心座標**: $(u,v)$ を R/G などにマッピングして表示する。補間が連続か、エッジ付近で飛んでいないかを確認する。
- **ソフトラスタの重み**: ソフトな重み $w_t$ を可視化すると、境界がどの程度ぼやけているか、温度パラメータの効き方が分かる。

これらは第 14 章 14.4.2 の可視化ツールの延長で、本格パイプラインや nvdiffrast 利用時にも同じ考え方が使えます。

---

## 18.5 マルチ GPU・分散処理とスケーラビリティ

### 18.5.1 データ並列

**データ並列** では、バッチの一部を各 GPU に割り当て、各 GPU で forward/backward を行い、勾配を集約してからオプティマイザで更新します。微分可能ラスタライザは **バッチ次元** で独立なので、PyTorch の `DataParallel` や `DistributedDataParallel` で、バッチを複数 GPU に分割するだけでスケールできます。各 GPU が同じメッシュ・異なるカメラや異なるメッシュをレンダリングする、といった使い方が典型です。

### 18.5.2 モデル・パイプラインの分割

単一のレンダリングが重すぎる場合、**パイプライン並列** のように「ラスタライズを GPU 0、interpolate を GPU 1」と分けることは可能だが、中間バッファの転送コストが大きくなりがちです。多くの場合は、**バッチを GPU 数で割るデータ並列** で十分で、メッシュや解像度を絞る方が現実的です。

### 18.5.3 スケーラビリティの限界

メッシュが非常に大きい場合、単一 GPU のメモリに載らないことがあります。そのときは、メッシュを **パッチに分割** して複数 GPU に載せ、それぞれでラスタライズしてから画像を合成する、といった設計になるが、合成の境界や勾配の一貫性が難しくなる。実務では、LOD でメッシュを簡略化するか、解像度を下げるか、データ並列でバッチを増やすかのいずれかで対処することが多いです。

---

## 18.6 浮動小数点の精度問題と ε（イプシロン）

### 18.6.1 三角形エッジ上にピクセル中心がある場合の挙動

ピクセル中心が **ちょうど三角形のエッジ上** にあるとき、エッジ関数 $E_{ij}(\mathbf{q}) = 0$ になります。浮動小数点では、計算誤差で $E$ が **わずかに正** になったり **わずかに負** になったりし、**内側と外側の判定がピクセルごとに振れる** ことがあります。その結果、

- 隣接ピクセルで「属する三角形」が違う、または「属する・属さない」が反転する。
- 勾配が不連続になり、最適化が不安定になる。

**対処**: エッジ関数の判定に **緩い閾値** を入れる。例えば $E \ge -\varepsilon$ を「内側」とみなす（$\varepsilon > 0$ は小さい定数）。すると、エッジ上のピクセルは常に内側に含まれる（または常に外側、どちらかに統一する）。閾値の取り方によっては、**描画される領域が 1 ピクセル分広がる/狭まる** ので、見た目と勾配の定義を両立させるように $\varepsilon$ を選ぶ。nvdiffrast でも同様の閾値や tie-break 規則が使われています。

### 18.6.2 float32 の精度限界による微分の不安定性

**float32** は有効桁数が約 7 桁です。座標の絶対値が大きいと、**相対誤差** が無視できなくなり、隣接ピクセル間の $E$ の差や重心座標の差が量子化されて、勾配が **階段状** になったり、勾配が 0 になったりします。

- **スケーリング**: クリップ空間やスクリーン座標のスケールを、なるべく $O(1)$ 前後に収める（カメラの near/far や解像度の設定）。遠くの物体が 1 ピクセル以下に潰れているような場合は、そもそも勾配の情報量が少ない。
- **float64**: 重要な経路だけ float64 で計算する、という手はあるが、GPU では float64 が遅く、メモリも 2 倍になる。まずは float32 でスケールと閾値を調整し、どうしても不安定な箇所だけ float64 を検討する。

### 18.6.3 Pixel Center Offset や微小値の扱いによる回避

- **Pixel center offset**: ピクセル $(i, j)$ の「中心」を $(i + 0.5, j + 0.5)$ とするか $(i, j)$ とするかは API や慣習で異なる。一貫して決めておかないと、エッジの位置が 0.5 ピクセルずれ、他ライブラリとの比較で混乱する。nvdiffrast や OpenGL の慣習に合わせると、$(i + 0.5, j + 0.5)$ がよく使われる。
- **微小値の扱い**: 除算の分母に **eps** を足して 0 除算を防ぐ（例: `inv_2A = 1.0 / (2*A + eps)`）。eps の大きさは、小さすぎると浮動小数点で無視され、大きすぎると結果が歪む。$10^{-7}$ 程度から試し、勾配チェックや可視化で妥当性を確認する。重心座標を $[0,1]$ にクリップするときも、クリップの境界で勾配が切れないよう、実装と微分の定義を揃える。

---

## 18.7 まとめと次章への接続

- **メモリレイアウト**: SoA と AoS のトレードオフ、共有メモリと局所性。勾配のアトミック加算とキャッシュの関係。
- **スケール**: 大きなメッシュ・高解像度ではメモリと計算量が増える。LOD・タイル・マルチ解像度学習・データ並列で対処する。
- **エッジケース**: クリッピング・カリング・退化三角形の一貫した扱い。自作では簡易版から始め、必要に応じて nvdiffrast に合わせて拡張する。
- **デバッグと可視化**: 勾配・マスク・重みの可視化で、逆伝播と境界の挙動を確認する。
- **マルチ GPU**: データ並列が主。バッチを分割して各 GPU でレンダリングし、勾配を集約する。
- **精度と ε**: エッジ上の閾値、float32 の限界とスケーリング、Pixel center の統一、除算やクリップでの微小値の扱い。

Part VI はここまでで、nvdiffrast の解剖と性能・堅牢性の実務的な話題が揃いました。  
次章（第 19 章、Part VII）では **逆レンダリングと最適化** に進み、テクスチャ最適化・メッシュ形状の逆最適化・マルチビュー一貫性・照明・材質推定・ニューラルメッシュとの組み合わせ・カスタム損失、そして座標系の一貫性を学びます。ここまでに築いたパイプラインを、実際の応用でどう使うかの総仕上げです。

---

*前: [第 17 章 nvdiffrast の解剖](Chapter17.md) | 次: [第 19 章 逆レンダリングと最適化](../Part07/Chapter19.md)*
