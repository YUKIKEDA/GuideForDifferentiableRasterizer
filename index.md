# 微分可能ラスタライザ 完全学習ガイド

初学者から nvdiffrast 相当のライブラリをスクラッチで自作できるレベルまでをカバーする包括的教材の目次です。

---

## Part I: 前提知識

### 1. 数学の基礎
- 1.1 線形代数（ベクトル・行列・変換）
- 1.2 微積分（偏微分・連鎖律・ヤコビ行列）
- 1.3 重心座標（定義・性質・応用）

### 2. コンピュータグラフィックス入門
- 2.1 レンダリングパイプライン概論
- 2.2 座標系と変換（モデル・ビュー・射影変換）
- 2.3 三角形ラスタライゼーションの原理
- 2.4 深度バッファと可視性判定
- 2.5 シェーディングの基礎（頂点属性・補間）

### 3. 深層学習と自動微分
- 3.1 自動微分（autograd）の仕組み
- 3.2 PyTorch / JAX における勾配計算
- 3.3 計算グラフと backward の流れ

---

## Part II: なぜ微分可能ラスタライザか

### 4. 逆問題としての 3D ビジョン
- 4.1 順問題と逆問題
- 4.2 微分可能レンダリングの必要性（最適化・逆伝播）
- 4.3 従来手法との比較（レイマーチング・ニューラルレンダリング）
- 4.4 既存の微分可能レンダラーの分類と比較
  - ラスタベース vs ボリュームベース vs ポイントベース
  - 各手法の長所・短所・適用場面

### 5. 微分可能性の障壁
- 5.1 離散演算が微分を阻む理由（if, argmax, ステップ関数）
- 5.2 ラスタライザにおける非微分点（ピクセル帰属・深度テスト・エッジ）
- 5.3 勾配の「穴」を埋めるアプローチ概観

---

## Part III: ラスタライゼーションの数学

### 6. 三角形とスクリーン空間
- 6.1 クリッピングと NDC
- 6.2 エッジ関数と内外判定
- 6.3 重心座標の計算とその微分
- 6.4 深度・属性の補間式
- 6.5 カスタム属性の補間（色・UV 以外の任意属性）
- 6.6 パースペクティブ補正の完全な微分
  - スクリーン空間の線形補間と 3D 空間での属性補間の違い
  - クリップ空間の $w$ による除算の逆伝播
  - 重心座標 $u, v$ と深度 $w$ の関係（$1/w$ 補間）および偏微分の連鎖律
  - スクリーン空間重心座標から 3D 空間重心座標への変換勾配（初心者が最もつまずくポイント）

### 7. アンチエイリアシング
- 7.1 エイリアシングの原因
- 7.2 マルチサンプル（MSAA）と解析的アンチエイリアシング
- 7.3 微分可能な境界の扱い

### 8. テクスチャとシェーディング
- 8.1 UV マッピングとテクスチャサンプリング
- 8.2 法線・ライティングとその勾配
- 8.3 微分可能なテクスチャサンプリング
- 8.4 Mipmap / LOD と勾配（高解像度テクスチャの扱い）

---

## Part IV: 微分可能ラスタライゼーションの理論

### 9. 古典的アプローチ
- 9.1 OpenDR（Loper & Black）の考え方
- 9.2 有限差分と数値勾配の限界
- 9.3 解析的勾配の必要性

### 10. ソフトラスタライゼーション
- 10.1 離散から連続へ（ソフトマックス・シグモイド）
- 10.2 ピクセルごとの「重み」と勾配の定義
- 10.3 Soft Rasterizer / DIB-R 系の定式化
- 10.4 ハイパーパラメータ（blend 係数・スケール）と安定性

### 11. サブディビジョンと解析的勾配
- 11.1 三角形の細分割による勾配の流れ
- 11.2 nvdiffrast の設計思想（解析的・決定的勾配）
- 11.3 アンチエイリアシングと勾配の一貫性（境界の扱いを先に）
- 11.4 エッジ・頂点・面に沿った勾配の導出
- 11.5 シルエット勾配の扱い
  - エッジ検出と境界ピクセルの特別扱い
  - nvdiffrast におけるシルエット勾配の役割

---

## Part V: 実装編 — スクラッチで作る

### 12. 実装上の考慮事項
- 12.1 退化三角形・背面・クリッピング
- 12.2 数値安定性（スケーリング・ログ空間）
- 12.3 メモリと計算コストのトレードオフ

### 13. 最小構成の CPU 実装
- 13.1 頂点変換（MVP）の実装と微分
- 13.2 単一三角形のラスタライズ（エッジ関数・重心座標）
- 13.3 深度バッファとフレームバッファ
- 13.4 勾配の手計算と autograd との照合

### 14. 微分可能ラスタライザのコア
- 14.1 ソフトラスタライザ（Python + PyTorch）の実装
- 14.2 解析的勾配（nvdiffrast 風）の導出と実装
- 14.3 頂点位置・UV・法線への逆伝播の検証
- 14.4 デバッグ手法
  - 勾配チェック（数値微分との比較）の体系的手法
  - 可視化ツール（勾配マップ・アテンションマップ）
- 14.5 アーキテクチャ設計: Deferred Interpolation（Rasterize-then-Interpolate）
  - 「幾何（三角形 ID・重心座標 $(u,v)$）」と「属性（色・法線）」の分離
  - メモリ効率と微分のしやすさのメリット（G-buffer 的な考え方、17 章への布石）

### 15. GPU 実装の基礎
- 15.1 CUDA / Metal の基本（カーネル・メモリ）
- 15.2 並列ラスタライゼーション（三角形並列 vs ピクセル並列）
- 15.3 アトミック操作と深度ソート
- 15.4 フレームワークとの連携（PyTorch C++ extension, custom op）
- 15.5 プロファイリングと最適化
  - ボトルネック特定
  - メモリバンド幅 vs 計算バウンド
- 15.6 C++ / CUDA 拡張のビルドエコシステム（システム・エンジニアリング）
  - `setuptools`・`setup.py`・`ninja` のベストプラクティス
  - JIT コンパイル（`load_inline`）vs AOT（事前）コンパイル
  - 実用ライブラリを作る上での最大の障壁となる環境構築・ビルド

### 16. 本格的なパイプライン
- 16.1 メッシュ入力（頂点・面・UV・法線）の扱い
- 16.2 バッチ処理とマルチ解像度
- 16.3 テクスチャサンプリングの微分可能実装
- 16.4 アンチエイリアシングの組み込み
- 16.5 半透明・ブレンディング（アルファ合成と勾配）
- 16.6 テストとベンチマーク（nvdiffrast との比較）

---

## Part VI: nvdiffrast レベルへ

### 17. nvdiffrast の解剖
- 17.1 アーキテクチャと API 設計（rasterize と interpolate の分離が最大の特徴）
- 17.2 カーネル構成（rasterize, interpolate, antialias）
- 17.3 勾配計算の数式とコードの対応
- 17.4 マルチ解像度・ミップマップとの関係
- 17.5 nvdiffrast のエッジケース処理
  - 具体的なバグ回避パターン
  - 数値安定性のための工夫
- 17.6 トポロジー参照の最適化
  - 頂点インデックスの効率的な扱い（隣接情報の事前計算、重複頂点）
  - 「UV はつながっていないが位置は同じ頂点」の勾配のマージ（`accumulate_grad` の挙動）
- 17.7 OpenGL コンテキストと CUDA の相互運用（Interop）
  - nvdiffrast が OpenGL / Vulkan を使う場合の理由
  - CUDA Graphics Resource Mapping の仕組み
  - ヘッドレスレンダリング（EGL）のセットアップ

### 18. 性能と堅牢性
- 18.1 メモリレイアウトとキャッシュ
- 18.2 大きなメッシュ・高解像度へのスケール
- 18.3 エッジケース（クリッピング・カリング・退化）
- 18.4 デバッグと可視化（勾配・マスク・重み）
- 18.5 マルチ GPU・分散処理とスケーラビリティ
- 18.6 浮動小数点の精度問題と ε（イプシロン）
  - 三角形エッジ上にピクセル中心がある場合の挙動
  - float32 の精度限界による微分の不安定性
  - Pixel Center Offset や微小値の扱いによる回避

---

## Part VII: 実践的応用例

### 19. 逆レンダリングと最適化
- 19.1 テクスチャ最適化の具体例
- 19.2 メッシュ形状の逆最適化
- 19.3 マルチビュー一貫性の利用
- 19.4 照明・材質推定
- 19.5 ニューラルメッシュ最適化との組み合わせ
- 19.6 カスタム損失・マルチタスク
- 19.7 他フレームワーク（JAX, TensorFlow）への移植の考え方
- 19.8 座標系の一貫性（Coordinate System Sanity）
  - PyTorch3D・OpenGL・OpenCV などライブラリごとの座標系の違い（右手/左手、Y-up/Y-down）
  - スクラッチ実装時の座標系変換とカメラモデルの整合性チェック
  - 微分は正しくても座標系の誤りで学習が進まない問題への対処

---

## Part VIII: 演習とプロジェクト

### 20. 段階的演習
- 20.1 演習 1: 固定三角形の CPU ラスタライザ
- 20.2 演習 2: ソフトラスタライザで形状を最適化
- 20.3 演習 3: 解析的勾配の導出と実装
- 20.4 演習 4: 簡単な GPU カーネル
- 20.5 演習 5: ミニ nvdiffrast の設計と実装
- 20.6 演習 6: デバッグ演習
  - 意図的にバグを含むコードの修正
  - 勾配消失・爆発への対処

### 21. 参考文献とリソース
- 21.1 論文一覧（OpenDR, Soft Rasterizer, DIB-R, nvdiffrast 等）
- 21.2 オープンソース実装へのリンク
- 21.3 関連トピック（NeRF, ニューラル BRDF, 物理ベースレンダリング）

---

## 想定読者と到達目標

| 段階 | 読者像 | 到達目標 |
|------|--------|----------|
| Part I–II | 初学者 | なぜ微分可能ラスタライザが必要か説明でき、パイプラインと微分の障壁を理解する |
| Part III–IV | 中級者 | ラスタライゼーションとその微分を数式で扱い、ソフト／解析的アプローチを実装できる |
| Part V–VI | 上級者 | GPU 実装を含む自作ライブラリを設計し、nvdiffrast と同等の機能・品質を目指せる |
| Part VII | 実務志向 | テクスチャ・形状・照明の逆最適化など、実践的応用に繋げられる |
| Part VIII | 全員 | 演習で手を動かし、デバッグ演習を含めて逆レンダリングに繋げられる |

---

*本教材は順次、各章の本文を追加していく形式で拡張します。*
