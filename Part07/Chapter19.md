# 第19章 逆レンダリングと最適化

Part VII では **実践的応用例** を扱います。本章では、微分可能ラスタライザを **逆レンダリングと最適化** でどう使うかを整理します。テクスチャ最適化の具体例（19.1）、メッシュ形状の逆最適化（19.2）、マルチビュー一貫性の利用（19.3）、照明・材質推定（19.4）、ニューラルメッシュ最適化との組み合わせ（19.5）、カスタム損失・マルチタスク（19.6）、他フレームワークへの移植の考え方（19.7）、そして **座標系の一貫性**（19.8）を学びます。ここまでに築いたパイプラインを、実際の研究・開発でどう組み立てるかの総仕上げです。

---

## 19.1 テクスチャ最適化の具体例

### 19.1.1 問題の定式化

**テクスチャ最適化** では、目標画像（または複数視点の画像）に「できるだけ近い」レンダリング結果になるように、**テクスチャ**（Texel の値）を更新します。

- **入力**: メッシュ（形状・UV）、カメラ、目標画像 $\mathbf{I}_{\text{target}}$。
- **変数**: テクスチャ $\mathbf{T}$（勾配が必要）。
- **損失**: $\mathcal{L} = \|\mathbf{I}_{\text{render}}(\mathbf{T}) - \mathbf{I}_{\text{target}}\|^2$ や、知覚損失（VGG など）の組み合わせ。
- **更新**: $\mathbf{T} \leftarrow \mathbf{T} - \eta \nabla_{\mathbf{T}} \mathcal{L}$。微分可能ラスタライザでレンダリングし、backward で $\nabla_{\mathbf{T}} \mathcal{L}$ を得る（第 8 章 8.3）。

形状とカメラは固定、**テクスチャだけ** を最適化するのが最もシンプルな設定です。

### 19.1.2 実装の流れ

1. テクスチャを `torch.nn.Parameter` または最適化対象のテンソルで用意する。
2. 各イテレーションで、MVP → rasterize → interpolate(UV) → texture_sample(tex) で画像を生成する。
3. 損失を計算し、`loss.backward()` でテクスチャへの勾配を求める。
4. オプティマイザでテクスチャを更新する。

UV も最適化する場合は、interpolate の入力である頂点 UV をパラメータに加え、同様に勾配を流します。解像度を段階的に上げるマルチ解像度学習（第 16 章）を組み合わせると、収束が安定しやすいです。

### 19.1.3 注意点

- **初期値**: テクスチャをランダムや平均色で初期化するか、既存のテクスチャから始めるか。目標画像との乖離が大きいと、局所解に陥りやすい。
- **正則化**: テクスチャの滑らかさ（Laplacian など）を正則化項に加えると、ノイジーなテクスチャを抑えられる。
- **Mipmap**: 高解像度テクスチャでは勾配のメモリが大きい。第 8 章 8.4 の LOD 固定や、解像度を段階的に上げることで対応する。

---

## 19.2 メッシュ形状の逆最適化

### 19.2.1 シルエット・マルチビューとの一致

**形状の逆最適化** では、目標とする **シルエット**（輪郭）や **マルチビュー画像** に合うように、**頂点位置** を更新します。

- **シルエット損失**: レンダリングしたマスク（オブジェクト領域を 1、背景を 0）と、目標マスクの差（L2 や IoU の負など）を損失にする。微分可能ラスタライザでは、**シルエット勾配**（第 11 章）が輪郭を動かす頂点に勾配を届かせる。
- **マルチビュー**: 複数カメラからレンダリングし、各視点での目標画像との損失の和を最小化する。形状が一貫して説明できるようにする。

頂点位置を `nn.Parameter` にし、rasterize の backward から得た勾配で更新します。メッシュのトポロジー（面の接続）は固定し、**頂点の位置だけ** を動かすのが一般的です。

### 19.2.2 正則化と制約

- **滑らかさ**: 隣接頂点の位置差を penalize して、デコボコを抑える。
- **変形の大きさ**: 初期形状からの変位を抑える正則化で、過度な変形を防ぐ。
- **物理的制約**: ひび割れや自己交差を避けるため、制約を損失に組み込むか、投影で feasible な領域に留める。

単一画像からの 3D 再構成では、形状が一意に決まらないため、正則化と prior が重要になります。

---

## 19.3 マルチビュー一貫性の利用

### 19.3.1 複数視点での損失

**マルチビュー一貫性** は、同じシーンを複数の視点からレンダリングした結果が、それぞれの目標画像（実写など）と一致するように最適化する考え方です。

- カメラ $c = 1, \ldots, C$ について、レンダリング画像 $\mathbf{I}_c$ と目標 $\mathbf{I}_{\text{target},c}$ の損失 $\mathcal{L}_c$ を計算し、$\mathcal{L} = \sum_c \mathcal{L}_c$ を最小化する。
- 形状・テクスチャ・照明などを共有し、**全視点で一貫した** 3D 表現を得る。単一視点では曖昧な部分が、複数視点で拘束される。

微分可能ラスタライザは、各視点で forward/backward を行い、勾配を **頂点・テクスチャなどに加算** すればよい（同じパラメータを共有しているため）。

### 19.3.2 視点の選び方

- **バッチ**: 複数カメラを 1 バッチにまとめてレンダリングし、一度の backward で全視点の勾配を集約できる（メモリが許す範囲で）。
- **サンプリング**: カメラ数が多い場合は、イテレーションごとにランダムにカメラをサンプルし、確率的に最適化する。

---

## 19.4 照明・材質推定

### 19.4.1 照明のパラメータ化

**照明** を方向・強度・色などでパラメータ化し、レンダリング結果が目標画像に近づくようにそのパラメータを最適化します。

- **環境マップ**: 球面や立方体マップで環境光を表し、そのテクスチャ（または係数）を最適化する。
- **点光源・方向光**: 位置・方向・強度・色をパラメータにし、シェーディング式（第 8 章 8.2）の入力とする。シェーディングが微分可能なら、照明パラメータへの勾配は自動で流れる。

形状・テクスチャを固定し、照明だけを推定する設定や、形状・テクスチャ・照明を同時に推定する設定が考えられます。

### 19.4.2 材質推定

**BRDF**（反射モデル）のパラメータ（拡散色・スペキュラ強度・粗さなど）を最適化する場合も、シェーディングを微分可能に書けば、同様に勾配で更新できます。物理ベースレンダリング（PBR）と組み合わせる場合は、レンダリング式が複雑になるが、原理は「レンダリング = 微分可能な関数」なので、逆伝播で材質パラメータに勾配が届くように設計します。

---

## 19.5 ニューラルメッシュ最適化との組み合わせ

### 19.5.1 ニューラルネットワークがメッシュを出力する場合

**ニューラルネットワーク** が頂点位置・テクスチャ・法線などを出力し、その出力を **微分可能ラスタライザ** でレンダリングして損失を計算する、というパイプラインはよく使われます（例: 単一画像からの 3D メッシュ推定）。

- ネットワークの出力が **メッシュ**（頂点・面・属性）であり、それをラスタライザに入力する。
- 損失はレンダリング結果（と目標画像）で定義され、backward で **ネットワークのパラメータ** まで勾配が流れる。ラスタライザは「メッシュ → 画像」の微分可能なブロックとして、計算グラフに組み込まれる。

DIB-R や nvdiffrast を使った 3D 再構成論文の多くが、この形です。

### 19.5.2 ハイブリッド表現

メッシュと **ニューラルテクスチャ**（各頂点や Texel にニューラル特徴を持たせ、小さな MLP で色を返す）を組み合わせる場合も、ラスタライザは「幾何と補間」までを担当し、色はニューラルモジュールが担当する。そのモジュールが微分可能なら、全体が end-to-end で学習できます。

---

## 19.6 カスタム損失・マルチタスク

### 19.6.1 損失の設計

- **L1 / L2**: ピクセルごとの色の差。シンプルで勾配も安定しやすい。
- **知覚損失**: VGG などの特徴量の差。見た目の質感に効くが、勾配のスケールや層の選び方に注意する。
- **シルエット損失**: マスクの一致。形状最適化で重要（19.2）。
- **敵対的損失**: ディスクリミネータを導入する場合、ラスタライザの出力が discriminator に入り、その勾配がラスタライザ経由でメッシュ・テクスチャに流れる。実装はやや複雑になるが、リアルさの向上に使われる。

### 19.6.2 マルチタスク

複数の損失を重み付きで足す: $\mathcal{L} = \lambda_1 \mathcal{L}_{\text{color}} + \lambda_2 \mathcal{L}_{\text{silhouette}} + \lambda_3 \mathcal{L}_{\text{reg}}$。重みのバランスは課題に依存するため、検証データで調整する。タスクごとに勾配のスケールが違う場合は、重みで調整するか、勾配の正規化を検討します。

---

## 19.7 他フレームワーク（JAX, TensorFlow）への移植の考え方

### 19.7.1 共通する考え方

微分可能ラスタライザの **入出力** は、フレームワークに依存しません。

- **入力**: 頂点（クリップ空間）、面、属性（UV・法線・色など）、解像度など。
- **出力**: 画像（色・深度）、必要なら幾何バッファ。
- **勾配**: 損失から「出力の勾配」が与えられたとき、「入力の勾配」を返す backward を定義する。

このインターフェースを満たせば、**PyTorch** では `torch.autograd.Function`、**JAX** では `jax.custom_vjp`、**TensorFlow** では `tf.custom_gradient` でラップし、それぞれのオプティマイザや学習ループに組み込めます。

### 19.7.2 JAX の場合

JAX は **関数** を基本とするため、ラスタライザを「関数」として実装し、`jax.custom_vjp` で forward と **vjp**（vector-Jacobian product、つまり backward に相当）を定義します。Python で書いたラスタライザをそのまま JAX の primitive として登録するか、C++/CUDA で書いたものを JAX の external call で呼ぶ形になります。勾配の定義は PyTorch の backward と同じ式でよいです。

### 19.7.3 TensorFlow の場合

TensorFlow 2 では `tf.custom_gradient` で、forward と勾配関数を登録します。入力・出力は `tf.Tensor` に揃え、勾配関数は「上流の勾配」を受け取り「入力の勾配」を返すようにします。実装の核（数式とアルゴリズム）は PyTorch 版と共通にし、テンソル API の違いだけ吸収するラッパーを書くと移植が楽です。

---

## 19.8 座標系の一貫性（Coordinate System Sanity）

### 19.8.1 PyTorch3D・OpenGL・OpenCV などライブラリごとの座標系の違い

**右手系 / 左手系**、**Y-up / Y-down**、**NDC の範囲**、**カメラの視線方向**（+z か -z か）は、ライブラリや API によって異なります。

| 環境 | 座標系の例 | 備考 |
|------|------------|------|
| **OpenGL** | 右手系、Y-up、NDC は通常 $[-1,1]$、視線は -z | 多くの GPU API の基準 |
| **Vulkan** | 左手系、Y-down など | OpenGL と NDC やクリップが異なることがある |
| **OpenCV** | カメラは通常 Y-down、右手系 | 画像座標と 3D の対応に注意 |
| **PyTorch3D** | NDC は $[-1,1]$、Y-up など | ドキュメントで確認 |
| **nvdiffrast** | OpenGL に合わせた設定がデフォルト | 他ライブラリと組み合わせる場合は変換が必要 |

スクラッチで実装する場合、**自分で選んだ座標系**（右手/左手、Y-up/Y-down、視線方向）を 1 つに固定し、カメラ行列・射影行列・スクリーン座標の変換をその定義に合わせて書きます。他ライブラリ（PyTorch3D、OpenCV のカメラ、nvdiffrast）と組み合わせる場合は、**変換行列** で座標を自分のパイプラインに合わせるか、相手の座標系に合わせるかをはっきり決めます。

### 19.8.2 スクラッチ実装時の座標系変換とカメラモデルの整合性チェック

- **チェックリスト**: (1) 頂点がカメラの「前」に来るとき、クリップ空間の $z$ や $w$ の符号はどうなるか。(2) NDC の $y$ とスクリーン座標の $y$ の対応（上向きが正か下向きが正か）。(3) ピクセル中心が $(i+0.5, j+0.5)$ か $(i,j)$ か。
- **単体テスト**: 既知の 3D 点を 1 つ射影し、期待するピクセル座標になるか手計算と照合する。立方体などの簡単なシーンを描き、他ライブラリ（PyTorch3D、nvdiffrast）と同じカメラで同じ画像になるか比較する。
- **カメラ行列**: 射影行列の near/far や fov の定義（縦か横か、ラジアンか度か）をドキュメントに残し、他モジュール（カメラ推定など）と一致させる。

### 19.8.3 微分は正しくても座標系の誤りで学習が進まない問題への対処

**勾配は正しく計算されている** が、**座標系の取り違え**（左右反転、上下反転、スケールのずれ）があると、更新の方向が意味的に誤り、学習が進まない・発散することがあります。

- **症状**: 損失が減らない、形状やテクスチャが不自然に歪む、他ライブラリと同じ入力で結果が一致しない。
- **対処**: 座標系を 1 つに固定し、カメラ行列・射影・スクリーン変換を再確認する。既知のシーンで「この点はこのピクセルに写る」を検証する。nvdiffrast や PyTorch3D のサンプルと、同じメッシュ・同じカメラでレンダリング結果を比較し、差があれば変換行列を疑う。

座標系の不整合は、デバッグが難しくなりがちなので、**最初に座標系を明文化し、テストで検証する** 習慣をつけると、後からの修正コストを減らせます。

---

## 19.9 まとめと次章への接続

- **テクスチャ最適化**: 目標画像に合わせて Texel を更新。損失と backward でテクスチャに勾配を流す。正則化・マルチ解像度を組み合わせる。
- **形状の逆最適化**: シルエット・マルチビューとの一致で頂点位置を更新。シルエット勾配と正則化が重要。
- **マルチビュー一貫性**: 複数視点の損失で一貫した 3D 表現を得る。勾配は共有パラメータに加算する。
- **照明・材質**: 照明や BRDF のパラメータを微分可能にし、逆伝播で推定する。
- **ニューラルメッシュ**: ネットワークがメッシュを出力し、ラスタライザでレンダリングして end-to-end 学習。ハイブリッド表現も可能。
- **カスタム損失・マルチタスク**: L1/L2・知覚・シルエット・正則化を組み合わせ、重みでバランスを取る。
- **他フレームワーク**: 入出力と勾配のインターフェースを揃え、JAX は custom_vjp、TensorFlow は custom_gradient でラップする。
- **座標系**: 右手/左手、Y-up/Y-down、視線方向を統一し、他ライブラリとの変換とテストで整合性を保つ。座標の誤りは学習不全の原因になる。

Part VII はここまでで、逆レンダリングと最適化の実践的な設計が揃いました。  
次章（第 20 章、Part VIII）では **段階的演習** に進み、固定三角形の CPU ラスタライザからソフトラスタ・解析的勾配・GPU カーネル・ミニ nvdiffrast・デバッグ演習まで、手を動かして習得する流れを学びます。

---

*前: [第 18 章 性能と堅牢性](../Part06/Chapter18.md) | 次: [第 20 章 段階的演習](../Part08/Chapter20.md)*
