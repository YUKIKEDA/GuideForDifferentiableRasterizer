# 第25章 検証と nvdiffrast との比較

Part IX のフルスクラッチ実装（第 22–24 章）が正しく動くことを確認し、**テスト戦略**（25.0）、**数値勾配との一致**（25.1）、**レンダリング結果・勾配の可視化**（25.2）、**パフォーマンスとエッジケースのベンチマーク**（25.3）を扱います。あわせて、設計思想の観点から **nvdiffrast** との対応関係に触れ、外部ライブラリと比較する場合の考え方を示します。

---

## 25.0 テスト戦略（全体方針）

### 25.0.1 テストの目的と範囲

**目的**: (1) 実装が仕様どおりに動くこと（正確性）、(2) CPU と GPU が同じ入力に対して同じ出力を出すこと（一貫性）、(3) 勾配が数値微分と一致すること（逆伝播の正しさ）、(4) エッジケースでクラッシュや未定義動作を起こさないこと（堅牢性）、(5) 性能が許容範囲内であること、を段階的に保証する。

**範囲**: 第 22 章の I/F（rasterizer_cpu_forward/backward、rasterizer_d3d12_forward/backward）および math_util、types.h で定義したデータ形式。シェーダー（HLSL）は GPU パスを通した結果で検証する。あわせて **nvdiffrast との比較検証**（25.2.3）を検証範囲に含め、同一入力での出力・勾配の一致を第三の検証軸とする。外部依存（Windows SDK、D3D12 ドライバ、vcpkg）はテスト環境で固定し、再現性を確保する。

### 25.0.2 テストの階層（単体・結合・システム・リグレッション）

| 階層 | 対象 | 内容 | 実行頻度の目安 |
|------|------|------|----------------|
| **単体（Unit）** | 関数・モジュール単位 | math_util の MVP・ndc_to_screen、エッジ関数・重心座標の計算、1 ピクセル分の補間・逆伝播の式 | コード変更のたびに全件 |
| **結合（Integration）** | パイプライン単位 | ラスタライザ forward 全体（入力→幾何・フレーム）、backward 全体（dL_d_frame→vertex_grad）、CPU と GPU の出力一致 | パイプライン変更のたび |
| **システム（System）** | 端末シナリオ | 所定のメッシュ・カメラでレンダリング→損失計算→backward→勾配で頂点更新、を 1 本のシナリオで実行 | リリース前・大きな変更後 |
| **リグレッション** | 既存テスト一式 | 上記すべてを自動実行し、以前のベースラインと比較 | CI または手動で定期的に |

単体テストで「式の実装」を、結合テストで「データの流れとバッファレイアウト」を、システムテストで「逆レンダリングとしての振る舞い」を検証する。失敗時は **単体→結合→システム** の順で切り分ける。

### 25.0.3 テスト設計の考え方（入力・期待値・カバレッジ）

- **入力の設計**: **境界値**（解像度 1×1、三角形 0 個、頂点 3 個のみ）、**典型値**（例: 256×256、100 三角形、数百頂点）、**ストレス**（高解像度・多数三角形）を用意する。座標系は第 22 章に合わせ、NDC 内・外、Y の向き、深度の前後関係を意図したデータを作る。
- **期待値の決め方**: (1) **数値微分**（有限差分）を解析的勾配の正解として使う、(2) **CPU 実装** を GPU の正解参照（リファレンス）として使う、(3) **不変式**（例: 勾配の対称性、特定の損失での勾配の符号）で検証する、(4) **ゴールデン参照**（一度正しいと確認した出力を保存し、以降はそれと比較する）を採用する。本教材では (1)(2) を主とし、(3)(4) を補助とする。
- **カバレッジ**: 可能なら **ピクセルカバレッジ**（どのピクセルが「三角形の内側」「エッジ上」「背景」として扱われたか）や **三角形カバレッジ**（全三角形が少なくとも 1 ピクセルに描画されたか）を記録し、意図しない未使用コードや分岐がないか確認する。必須ではないが、エッジケースの見落としを減らせる。

### 25.0.4 テストデータとテストケースの体系

**テストデータ**は次を用意する（リポジトリに `tests/data/` などを切って格納する想定）。

- **minimal**: 頂点 3、三角形 1、解像度 16×16。単一三角形が画面中央付近に収まる。MVP は単位行列に近いもの。
- **two_triangles**: 頂点 6、三角形 2。2 つが重なり、深度が異なる（手前・奥）。深度テストと可視性の検証用。
- **grid**: 頂点・三角形が格子状。多数三角形だが規則的。スケーリングと安定性の検証用。
- **edge_cases**: 退化三角形（一直線・重複頂点）、背面のみ、画面外、同一深度の 2 三角形、極端なアスペクト比や深度値。

**テストケース一覧**は 25.1–25.3 で述べる各項目を、**テスト ID・入力・期待される振る舞い・合格基準** の形式で整理する。例: `T-forward-001: minimal で forward → 幾何バッファの tri_id が 0 または 1 のみ、フレームバッファに NaN なし`。

### 25.0.5 合格基準の定量化と自動化

- **数値一致**: 解析的勾配と数値勾配の相対誤差を全成分で計算し、**最大相対誤差** が閾値（例: $10^{-2}$）以下、かつ **平均相対誤差** がより小さい閾値（例: $10^{-3}$）以下とする。数値勾配が 0 に近い成分は絶対誤差で判定する（例: $|\nabla_{\text{ana}} - \nabla_{\text{num}}| < 10^{-6}$）。
- **CPU vs GPU**: 幾何・フレーム・勾配バッファの各要素について、**絶対誤差** が閾値（例: $10^{-5}$）以下、または **相対誤差** が閾値以下とする。tri_id は完全一致とする。
- **エッジケース**: クラッシュ・assert 失敗・NaN/Inf の出力がないこと。仕様どおり「スキップ」「描画」「勾配 0」であることをアサートする。
- **自動化**: テストは **実行可能なテストプログラム**（例: `tests/test_gradient_check.cpp`、`tests/test_cpu_gpu_match.cpp`）にまとめ、CMake で `add_executable` + `add_test` し、`ctest` または CI で実行する。GPU テストは D3D12 が利用可能な環境でのみ有効にし、CI で GPU が無い場合はスキップするオプションを用意する。

---

## 25.1 数値勾配との一致確認（CPU 実装 vs GPU 実装）

### 25.1.1 解析的勾配の妥当性（数値微分との比較）

逆伝播で計算した勾配が正しいかは、**数値微分（有限差分）** と比較して検証する。第 14 章 14.4 の勾配チェックと同様の考え方である。

**手順**:

1. **入力の準備**: テストデータ `minimal` または `two_triangles` を用い、頂点位置・属性・MVP を固定する。解像度は小さめ（例: 32×32）でよい。順方向でフレームバッファを得る。
2. **損失の定義**: スカラー損失 $L$ を決める。推奨は次のいずれか。
   - **和損失**: $L = \sum_{i,j} (R_{ij} + G_{ij} + B_{ij})$。勾配は「そのピクセルに 1 が伝わる」ので、すべての描画ピクセルで backward が動く。
   - **L2 損失**: 目標画像 $I^*$ に対し $L = \sum_{i,j,c} (C_{ijc} - I^*_{ijc})^2$。実用に近く、勾配のスケールも大きめになる。
   - **1 ピクセル損失**: 特定の 1 ピクセル $(i_0, j_0)$ の 1 チャネルだけ $L = R_{i_0 j_0}$ とする。寄与する三角形・頂点が限られるため、デバッグ時に原因を追いやすい。
3. **解析的勾配**: 上記 $L$ に対応する `dL_d_frame` を構成し（和損失なら全ピクセル 1、L2 なら $2(C - I^*)$）、backward を実行して `vertex_grad` を得る。
4. **数値勾配**: 各頂点 $k$、各成分 $d \in \{x, y, z, \text{color}_R, \text{color}_G, \ldots\}$ について、$d$ を $\varepsilon$ だけ perturb した入力で forward を再実行し、$L$ を取得。中心差分 $\frac{\partial L}{\partial d} \approx \frac{L(d+\varepsilon) - L(d-\varepsilon)}{2\varepsilon}$ を計算する。
5. **比較と合格判定**: 成分ごとに相対誤差 $e_{\text{rel}} = \frac{|\nabla_{\text{ana}} - \nabla_{\text{num}}|}{\max(|\nabla_{\text{num}}|, \tau)}$ と絶対誤差 $e_{\text{abs}} = |\nabla_{\text{ana}} - \nabla_{\text{num}}|$ を計算する。$|\nabla_{\text{num}}| \ge \tau$ のときは $e_{\text{rel}} < 10^{-2}$（緩め）または $e_{\text{rel}} < 10^{-3}$（厳しめ）で合格。$|\nabla_{\text{num}}| < \tau$ のときは $e_{\text{abs}} < 10^{-6}$ で合格。全成分の **最大** がこの条件を満たすことを要求する。

**パラメータの推奨**:

| 項目 | 推奨値 | 備考 |
|------|--------|------|
| $\varepsilon$（位置） | $10^{-5}$ ～ $10^{-4}$ | スケールがメートル単位なら $10^{-5}$、NDC 付近なら $10^{-4}$ も可 |
| $\varepsilon$（属性） | $10^{-5}$ ～ $10^{-4}$ | 色は 0～1 なので $10^{-5}$ が無難 |
| $\tau$ | $10^{-10}$ | 零除算回避。数値勾配が 0 に近い成分は絶対誤差で判定 |
| 合格閾値（相対） | $10^{-2}$（初回）、$10^{-3}$（厳格） | エッジ付近では勾配が不連続になり得るため、厳格化は「内部のみ」のテストで |

**テストケース一覧（勾配チェック）**:

| ID | 入力 | 損失 | 検証対象 | 合格基準 |
|----|------|------|----------|----------|
| T-grad-001 | minimal、1 三角形 | 和損失 | 全頂点の position 勾配 | 最大相対誤差 $< 10^{-2}$ |
| T-grad-002 | minimal | 和損失 | 全頂点の color 勾配 | 同上 |
| T-grad-003 | two_triangles | 和損失 | 手前・奥両方の頂点の勾配 | 同上。奥の三角形の頂点は見えているピクセルからのみ勾配が非零 |
| T-grad-004 | minimal | 1 ピクセル損失 | そのピクセルを覆盖する三角形の 3 頂点のみ勾配非零 | 他頂点の勾配は 0、3 頂点は数値微分と一致 |
| T-grad-005 | edge_cases（退化含む） | 和損失 | クラッシュ・NaN なし、退化三角形の頂点への勾配は 0 | アサートのみ |

**注意**: 退化三角形やエッジ上のピクセルでは勾配が不連続になり得るため、まず T-grad-001～002 のような「単一三角形・内部のみ」で合格させ、そのうえで T-grad-003 以降を追加する。

### 25.1.2 CPU 実装 vs GPU 実装の出力一致

第 22 章の設計では、**同じ入力**（頂点・三角形・MVP・解像度）を **CPU ラスタライザ**（第 23 章）と **GPU ラスタライザ**（第 24 章）に渡し、**同じデータ形式**（幾何バッファ・フレームバッファ・勾配バッファ）で結果を比較できる。

**手順**:

1. **順方向**: 同一の頂点・三角形・MVP で `rasterizer_cpu_forward` と `rasterizer_d3d12_forward` を実行する。GPU の結果は READBACK で読み戻し、CPU の出力と比較する。
2. **比較項目**:
   - **幾何バッファ**: 各ピクセルの `tri_id`, `u`, `v`, `depth`。`tri_id` は **完全一致** を要求する。`u`, `v`, `depth` は浮動小数点の誤差を許容し、絶対誤差 $< 10^{-5}$ または相対誤差 $< 10^{-4}$ で合格とする。
   - **フレームバッファ**: 各ピクセルの色（R, G, B, alpha）。補間式と $1/w$ の計算が同一なら一致する。同上の誤差閾値で比較する。
3. **逆方向**: 同一の `dL_d_frame` で `rasterizer_cpu_backward` と `rasterizer_d3d12_backward` を実行し、`vertex_grad` を比較する。GPU の勾配は READBACK で取得する。整数エンコード等を使っている場合はデコード後の float で比較する。勾配は「加算」のため順序に依存するが、同じ入力・同じ dL_d_frame なら結果は一致する。絶対誤差 $< 10^{-4}$ 程度を目安とする（アトミックの丸めで多少の差は許容する場合もある）。

**テストケース一覧（CPU vs GPU 一致）**:

| ID | 入力 | 比較対象 | 合格基準 |
|----|------|----------|----------|
| T-match-001 | minimal | 幾何バッファ（tri_id, u, v, depth） | tri_id 完全一致、u/v/depth 絶対誤差 $< 10^{-5}$ |
| T-match-002 | minimal | フレームバッファ（R,G,B,alpha） | 絶対誤差 $< 10^{-5}$ または相対 $< 10^{-4}$ |
| T-match-003 | two_triangles | 幾何・フレーム | 同上。深度テストで手前が選ばれていることを tri_id と depth で確認 |
| T-match-004 | minimal | vertex_grad（backward 後） | 絶対誤差 $< 10^{-4}$（全頂点・全成分） |
| T-match-005 | grid（多数三角形） | 幾何・フレーム・勾配 | 同上。ストレステストとして解像度・三角形数を上げた場合も実行 |

**不一致時の切り分け**:

- **幾何バッファの tri_id が違う**: 深度の大小関係が CPU と GPU で逆になっている可能性。深度バッファの初期値、比較演算子（手前＝小さい）、および `InterlockedMin` の比較対象（uint 化した深度）を確認する。
- **u, v は一致するが depth が違う**: 深度の計算式（$z/w$ の線形補間）の実装差。クリップ空間の $z$, $w$ の取得が同じか確認する。
- **フレームバッファだけ違う**: 補間式（$1/w$ と $A/w$）または属性の読み方（頂点バッファのレイアウト）の差。
- **勾配が違う**: 逆伝播の式（補間→u,v→スクリーン→クリップ→MVP）のどれかが CPU と GPU で異なる。また GPU で整数エンコードしている場合はスケールとオーバーフローを確認する。

デバッグ時は、**単一三角形・解像度 8×8** など最小ケースで、該当ピクセルの幾何・フレーム・勾配を 1 つずつ print して CPU と GPU を並べると原因を特定しやすい。

---

## 25.2 レンダリング結果・勾配の可視化比較

### 25.2.1 フレームバッファの可視化

ラスタライザの **順方向** の出力（フレームバッファ）を画像として保存し、目視および簡易アサートで確認する。

**出力形式**: 各ピクセルの R, G, B（と必要なら alpha）を 0～1 の範囲でファイルに書き出す。PPM、PNG（stb_image_write 等）、または BMP など、テスト環境で読み書きできる形式にする。ファイル名は `out_forward_cpu.png` / `out_forward_gpu.png`、差分は `out_diff_forward.png` のように固定し、CI や手動で比較しやすくする。

**確認内容（チェックリスト）**:

| 確認項目 | 方法 | 合格基準 |
|----------|------|----------|
| 三角形の位置 | 単一三角形を画面中央付近に置き、レンダリング | 期待したピクセル範囲に非零の色が存在する |
| 色・補間 | 頂点に異なる色を設定 | 三角形内で頂点色が補間されてグラデーションになる（目視または隣接ピクセルの差が小さい） |
| 深度テスト | 2 三角形を重ね、手前・奥で異なる色 | 手前の色だけが見える。幾何バッファの tri_id が手前の三角形に対応 |
| 座標系（Y） | 三角形の上辺・下辺が期待どおり | 第 22 章の約束（y=0 が上端）と一致。テスト用に「上が赤・下が青」の三角形を描いて確認 |
| NaN/Inf | 全ピクセルを走査 | フレームバッファに NaN/Inf が 1 つも含まれない（アサートで自動化可） |

**差分画像**: CPU と GPU のフレームバッファを **同じ入力** で生成し、ピクセルごとの絶対差 `diff_ij = |C_cpu - C_gpu|` を計算する。差分画像をヒートマップとして保存（差が大きいほど目立つ色）し、差が閾値（例: $10^{-5}$）を超えるピクセル数が 0 であることをアサートするか、最大差分をログに出す。

### 25.2.2 勾配の可視化

**頂点位置への勾配**（`vertex_grad[k].d_position`）は、逆レンダリングで「どの頂点をどれだけ動かすと損失が減るか」を表す。可視化の例は次のとおり。

- **メッシュ上での表示**: 各頂点の勾配ベクトル $(d_x, d_y, d_z)$ の **大きさ** を色でマッピングする（例: 大きいほど赤、小さいほど青）。メッシュビューアや簡易レンダラで頂点カラーとして描画する。
- **成分ごとの 2D ヒートマップ**: 頂点 ID を横軸、勾配の $x$（または $y$, $z$）成分を縦軸にした 1D プロット、または頂点を 2D に並べたヒートマップ。勾配が異常に大きい／小さい頂点を発見しやすい。
- **画像空間での勾配**: 「フレームバッファへの勾配」`dL_d_frame` は既にピクセルごとの 2D 画像なので、R, G, B をそのまま画像として保存する（負の値は 0 にクリップするか、オフセットして表示する）。損失がどのピクセルに敏感かを目視できる。

**可視化のテスト戦略**: 可視化そのものは主に目視だが、次の **自動チェック** を追加すると再現性が上がる。

| ID | 内容 | 合格基準 |
|----|------|----------|
| T-viz-001 | 勾配のノルム | 全頂点の `vertex_grad` の L2 ノルムが、ある上限（例: 1e6）以下。爆発の検出 |
| T-viz-002 | 勾配の非零 | 和損失で 1 三角形のみのシーンでは、その 3 頂点の勾配が非零、他は零 | 勾配が意図した頂点にだけ流れているか |
| T-viz-003 | dL_d_frame の保存 | backward の入力 `dL_d_frame` を画像として保存 | 後から「どのピクセルに勾配を渡したか」を追える |

可視化により、勾配が特定の頂点やエッジに集中していないか、数値不安定で爆発していないかを確認できる。第 12 章の退化三角形・数値安定性の対策が効いているかも、意図的に degenerate な入力で試すと分かる。

### 25.2.3 nvdiffrast との比較検証（方針・戦略・テストケース）

nvdiffrast（Part VI 第 17 章）は、**rasterize と interpolate の分離**・**解析的勾配** という点で本 Part IX の設計と一致している。**同一条件で両者を実行し、出力と勾配を比較する検証** を必須の検証項目として位置づけ、方策・戦略・合格基準を明確にする。

#### 目的と位置づけ

- **目的**: 自作実装が、業界で広く使われる nvdiffrast と **同じ入力に対して同じ挙動（順方向の画像・幾何、逆方向の頂点勾配）** を持つことを示す。これにより、実装の正しさを外部リファレンスで裏付け、逆レンダリングや学習パイプラインに載せたときの信頼性を高める。
- **位置づけ**: CPU vs GPU 一致（T-match-*）と数値勾配（T-grad-*）に加え、**第三の検証軸** とする。nvdiffrast は PyTorch/CUDA、自作は D3D12/C++ のため同一プロセスでは動かさず、**共通入力データをファイル（またはシード固定の生成）で共有し、両方の実行結果を比較する**。

#### 比較可能なサブセットの定義

比較は **両者が共通して持つ機能** に限定する。

| 機能 | nvdiffrast | Part IX 自作 | 比較で使うか |
|------|------------|--------------|--------------|
| クリップ空間 → 幾何バッファ（rasterize） | ○ | ○（ラスタライズカーネル） | ○ |
| 幾何 + 頂点属性 → 画像（interpolate） | ○ | ○（補間パス） | ○ |
| 頂点位置・属性への勾配（backward） | ○ | ○ | ○ |
| テクスチャサンプリング | ○ | × | × 比較外 |
| アンチエイリアシング（antialias） | ○ | × | × 比較時は nvdiffrast も AA オフ |
| シルエット勾配（境界） | ○ | 最小実装では未実装可 | △ 実装していれば比較、していなければ境界ピクセルを許容差で緩める |

**検証時の前提**: nvdiffrast 側は **rasterize → interpolate のみ** を呼び、texture や antialias は使わない。解像度・メッシュ・カメラ（クリップ空間の頂点）を揃える。

#### 座標系・データ形式の差異と変換

第 17 章の通り、nvdiffrast は **OpenGL 慣習** をとる。Part IX の第 22 章とは次の差がある。

| 項目 | nvdiffrast（OpenGL） | Part IX（第 22 章） | 比較時の変換 |
|------|----------------------|---------------------|----------------|
| 画像の Y 方向 | 行 0 = **下**（ボトムアップ） | 行 0 = **上** | 自作→nvdiffrast 比較時は、自作の画像を **上下反転** してから比較する。または nvdiffrast の出力を反転して自作と比較。 |
| 深度 $z/w$ の意味 | **奥ほど大きい**（視線方向に正） | 第 22 章では **手前ほど小さい** を採用 | 深度の大小関係で「手前」を決めているので、比較時は **どちらの三角形が描かれるか**（tri_id）と **色** が一致すればよい。深度値そのものは符号・スケールを揃えて比較する。 |
| rast のチャネル順 | [u, v, z/w, tri_id]（チャネル 0～3） | GeometryPixel: u, v, depth, tri_id | 同じ並び。tri_id は nvdiffrast が 1-based（0=背景）、自作も 1-based に合わせる。 |
| 重心座標の頂点対応 | 第 1 頂点 (1,0)、第 2 (0,1)、第 3 (0,0) | 第 22 章も $u=b_1$, $v=b_2$、$b_0=1-u-v$ | 同じ定義なら変換不要。 |

**変換手順（再現可能に書く）**:

1. **入力**: クリップ空間の頂点 `pos`（float, N×4）、三角形 `tri`（int, M×3）、解像度 `(W, H)` を、**共通のテストデータファイル**（例: NPZ や JSON）に保存する。MVP は自作側で適用した **クリップ空間の頂点** をそのまま nvdiffrast に渡すので、nvdiffrast には「既にクリップ空間」の pos を渡す。
2. **順方向の比較**: 両者で rasterize + interpolate（色のみ）を実行。自作のフレームバッファは **行 0 = 上** なので、nvdiffrast の出力（行 0 = 下）と比較するときは、自作の画像を **Y 方向に反転** したものと nvdiffrast の画像をピクセルごとに比較する。幾何バッファ（u, v, depth, tri_id）も、ピクセル (x, y) の対応を「自作の (x, y) と nvdiffrast の (x, H-1-y)」で対応させる。
3. **逆方向の比較**: 同じ損失（例: 画像の和、または L2）と `dL_d_frame`（勾配入力）を両方に渡す。nvdiffrast の `dL_d_frame` はボトムアップなので、自作で使う `dL_d_frame` を「上から下」の並びで作り、nvdiffrast には「下から上」に並べ替えたものを渡すか、あるいは nvdiffrast の出力勾配を「頂点インデックス順」で取得し、自作の vertex_grad と **同じ頂点順** で比較する。座標系の差で勾配の符号が反転する可能性があるため、**頂点位置の勾配** は、Y など反転の影響を受ける成分は比較前に反転を打ち消す。

#### 入力の共通化と実行の流れ

1. **共通入力の生成**: テストデータ `minimal` または `two_triangles` について、**モデル空間の頂点** と **MVP 行列** を用意し、自作の math_util で **クリップ空間の頂点** を計算する。このクリップ空間の頂点 `pos` と、三角形 `tri`、解像度 `(W, H)` をファイルに書き出す（例: `tests/data/nv_compare_input.npz`）。頂点属性（色）も同じ順で保存する。
2. **自作の実行**: 同じクリップ空間の頂点（およびモデル空間の頂点 + MVP、またはクリップ空間を直接使うパスがあればそれ）で forward / backward を実行。結果（幾何バッファ、フレームバッファ、vertex_grad）をファイルに保存する（例: `out_ours.npz`）。
3. **nvdiffrast の実行**: Python スクリプトで、保存した `pos`, `tri`, 解像度、属性を読み込み、nvdiffrast の `rasterize` → `interpolate` を実行（antialias はオフ）。同じ損失で backward を実行し、頂点位置の勾配を取得。結果を保存（例: `out_nvdiffrast.npz`）。
4. **比較**: 上記の **変換（Y 反転、深度の対応）** をかけたうえで、両者のフレームバッファ・幾何バッファ・頂点勾配を数値比較する。

#### 比較項目と合格基準

| 比較項目 | 内容 | 合格基準 |
|----------|------|----------|
| 順方向・画像 | 補間された色（R,G,B） | ピクセル対応（Y 反転済み）で絶対誤差 $< 10^{-4}$ のピクセル割合が 99% 以上。または PSNR > 40 dB。 |
| 順方向・幾何 | tri_id, u, v, depth | tri_id は完全一致。u, v, depth は絶対誤差 $< 10^{-5}$（描画ピクセルのみ）。背景ピクセルは両方 0。 |
| 逆方向・頂点勾配 | 頂点位置への勾配 | 頂点順を揃え、座標系の反転を補正したうえで、相対誤差 $< 10^{-2}$ または絶対誤差 $< 10^{-5}$。 |

**既知の差**: ピクセル中心の取り方・エッジの内外判定の境界、シルエット勾配の有無により、**エッジ付近の 1 ピクセル程度** で差が出る可能性はある。その場合は「エッジから 2 ピクセル以上内側」のピクセルだけを比較するか、合格基準を「99% のピクセルで一致」のように緩める。

#### テストケース一覧（nvdiffrast 比較）

| ID | 入力 | 比較内容 | 合格基準 |
|----|------|----------|----------|
| T-nv-001 | minimal（1 三角形、解像度 32×32） | 順方向: フレームバッファ、幾何バッファ | 上記の画像・幾何の合格基準を満たす |
| T-nv-002 | minimal | 逆方向: 頂点位置勾配（和損失） | 上記の勾配の合格基準を満たす |
| T-nv-003 | two_triangles（深度の異なる 2 三角形） | 順方向・逆方向 | 手前・奥の描画と勾配が nvdiffrast と一致する |
| T-nv-004 | grid（多数三角形） | 順方向の画像 | PSNR または 99% ピクセル一致。実行が完了すること |

#### 実行環境と自動化

- **nvdiffrast 側**: Python 3.x + PyTorch + nvdiffrast がインストールされた環境が必要。CI で GPU 付きランナーを使うか、手動で「共通入力」を生成し、別マシンで nvdiffrast を実行して結果ファイルを取得する。
- **自動化の形**: 自作のテストプログラムが「共通入力ファイル」を読み、自作の結果を `out_ours.npz` に書き出す。別途、Python スクリプト `tests/run_nvdiffrast_compare.py` が同じ入力で nvdiffrast を実行し `out_nvdiffrast.npz` を生成。最後に `tests/compare_nv_results.py` が両 NPZ を読み、Y 反転・深度の対応を適用したうえで上記の合格基準をチェックする。CI では「nvdiffrast が入っていれば T-nv-001～004 を実行、入っていなければスキップ」とする。
- **ドキュメント**: `tests/README_nv_compare.md` に、共通入力の形式、nvdiffrast のバージョン、変換の式（Y 反転の対応表）、合格基準の根拠を書いておく。再現性のため、nvdiffrast のバージョン（例: 0.2.9）を固定する。

このように、**nvdiffrast との比較検証** を「参考」ではなく、**入力の共通化・座標系変換・合格基準・テスト ID 付きケース・実行フロー** までを明示した **検証戦略** として組み込む。

---

## 25.3 パフォーマンスとエッジケースのベンチマーク

### 25.3.1 パフォーマンス測定

**CPU 実装**（第 23 章）と **GPU 実装**（第 24 章）の実行時間を、同一入力で比較する。

- **計測対象**: 順方向のみ、逆方向のみ、または forward + backward の 1 セット。それぞれ複数回実行し、平均や中央値を取る（ウォームアップ run を除く）。
- **変数**: 解像度（例: 256×256, 512×512, 1024×1024）、三角形数（例: 100, 1000, 10000）、頂点数。これらを変えて **スケーリング** を確認する。
- **CPU**: 単一スレッドで実装していれば、コア数に依らず 1 スレッドの性能が出る。マルチスレッド化（第 23 章で触れた深度ソートとあわせて三角形を分割）すると、スループットが上がる余地がある。
- **GPU**: ディスパッチのオーバーヘッド、バッファ転送（UPLOAD/READBACK）の時間を含めた「 end-to-end 」で測ると、実用時の体感に近い。転送を除いた「コンピュートのみ」も別途測ると、カーネル効率の評価になる。

**期待**: 解像度・三角形数が大きいほど GPU が有利になりやすい。小さい入力では CPU の方がオーバーヘッドが少なく速い場合もある。ベンチマーク結果を表やグラフにまとめ、Part IX の実装が「どの規模で CPU/GPU のどちらを選ぶとよいか」の目安にできる。

**パフォーマンステストの体系化**:

| ID | 変数 | 固定 | 計測内容 | 出力 |
|----|------|------|----------|------|
| T-perf-001 | 解像度 64, 256, 512, 1024 | 三角形 100 | CPU forward 時間 [ms] | 表：解像度 vs 時間 |
| T-perf-002 | 三角形 10, 100, 1000, 10000 | 解像度 256 | CPU forward 時間 | 表：三角形数 vs 時間 |
| T-perf-003 | 同上 | 同上 | GPU forward 時間（転送含む／含まない） | CPU との比較 |
| T-perf-004 | 同上 | 同上 | backward 時間 | forward との比を記録 |
| T-perf-005 | 解像度・三角形数を最大に | - | メモリ使用量（オプション） |  OOM しないことの確認 |

**ベースライン**: 一度「正しい」と確認した実装の実行時間をベースラインとして記録する（例: `baseline_cpu_256x256_100tri.json`）。リグレッションテストでは、同じ入力で「現在の実行時間がベースラインの 2 倍を超えない」などの条件を課すか、単にログに残して目視で確認する。

### 25.3.2 エッジケースのテスト

第 12 章で扱った **退化三角形・背面・クリッピング・数値安定性** が、実装で正しく扱われているかをテストする。各ケースを **テスト ID・入力・期待動作・合格基準** で定義し、可能なものはアサートで自動化する。

**エッジケース テストケース一覧**:

| ID | ケース | 入力の作り方 | 期待動作 | 合格基準（自動化） |
|----|--------|--------------|----------|--------------------|
| T-edge-001 | 退化（一直線） | 3 頂点を同一直線上に配置（例: (0,0,0), (1,0,0), (2,0,0)） | その三角形は描画されない | forward 後、幾何バッファにその tri_id が現れない。クラッシュ・NaN なし |
| T-edge-002 | 退化（重複頂点） | 同一座標の 3 頂点 | 同上 | 同上 |
| T-edge-003 | 背面（$2A<0$） | カメラから見て裏を向いた三角形 | カリング ON なら描画されない；OFF なら描画される | カリング仕様に合わせて tri_id の有無をアサート |
| T-edge-004 | 完全に画面外 | NDC で $x>1$ や $y<-1$ の位置に三角形 | 描画されない | 幾何バッファの tri_id がすべて 0（背景） |
| T-edge-005 | 一部クリップ | 三角形の一部だけ NDC 内 | 簡易実装では内側だけ描画、はみ出しは描画されてもよい（仕様による） | クラッシュ・NaN なし。描画ピクセル数が 0 より大きい |
| T-edge-006 | 三角形 0 個 | indices 空、num_triangles=0 | 全ピクセル背景 | 幾何バッファの tri_id がすべて 0。フレームバッファは背景色 |
| T-edge-007 | 解像度 1×1 | width=1, height=1 | 最大 1 ピクセルに 1 三角形 | クラッシュなし。1 三角形を置いたときそのピクセルの tri_id が 1 |
| T-edge-008 | 極端な深度 | $z/w$ が 0 に非常に近い、または 1 に非常に近い頂点 | 補間・深度比較で NaN/Inf が出ない | forward/backward の出力に NaN/Inf なし |
| T-edge-009 | 同一深度の 2 三角形 | 同じ $z/w$ の 2 三角形が同じピクセルを覆盖 | どちらか一方が描画される（実装依存） | そのピクセルの tri_id が 1 または 2 のいずれか。勾配は描かれた方の三角形に流れる |
| T-edge-010 | 大規模（ストレス） | 頂点 10 万、三角形 3 万、解像度 512×512 | 完了すること | タイムアウト（例: 60 秒）以内に forward が完了。クラッシュ・メモリ不足なし |

**実行順序**: まず T-edge-001, 002, 006, 007 で「異常入力でも落ちない」ことを確認し、続けて 003, 004, 005, 008, 009 で仕様どおりの描画・勾配を確認、最後に T-edge-010 でストレステストとする。

### 25.3.3 テストの実行順序と自動化（CI）

**推奨実行順序**（失敗時に原因を切り分けやすくするため）:

1. **単体**: math_util の MVP・ndc_to_screen のテスト（既存のユニットテストがあれば）。
2. **勾配チェック**: T-grad-001 → T-grad-002 → T-grad-003。解析的勾配が正しくなければ以降の CPU/GPU 一致は意味がない。
3. **CPU のみの forward/backward**: minimal で forward が期待どおりの画像を出すこと、backward が数値微分と一致することを確認。
4. **CPU vs GPU 一致**: T-match-001 ～ 005。GPU が無い環境ではスキップする。
5. **エッジケース**: T-edge-001 ～ 010。順に実行し、失敗した ID で止める。
6. **nvdiffrast との比較**: T-nv-001 ～ 004。共通入力データを生成したうえで、自作と nvdiffrast の両方を実行し、変換（Y 反転等）をかけた結果を比較する。nvdiffrast が利用可能な環境でのみ実行（CI ではオプション可）。
7. **可視化・パフォーマンス**: 必要に応じて手動または週次で実行。結果をログ・画像として保存する。

**自動化の形**:

- **テストプログラム**: `tests/test_forward.cpp`（forward の出力アサート）、`tests/test_gradient_check.cpp`（数値微分との比較）、`tests/test_cpu_gpu_match.cpp`（CPU vs GPU）、`tests/test_edge_cases.cpp`（エッジケース一覧）などを用意する。
- **CMake**: `enable_testing()` と `add_test(NAME T-grad-001 COMMAND test_gradient_check --case 001)` で ctest に登録する。GPU テストは `if(D3D12_AVAILABLE)` などで条件付きにする。
- **CI**: GitHub Actions や他の CI では、ビルド後に `ctest --output-on-failure` を実行する。GPU が使えない環境では、CPU のみのテスト（T-grad-*, T-edge-001,002,006,007 など）を必須とし、T-match-* と T-perf-* はオプションまたはスキップとする。
- **リグレッション**: ベースライン画像やベースライン数値（勾配のノルム、数値微分との誤差）を `tests/baseline/` にコミットし、テストで「現在の出力とベースラインの差が閾値以内」をチェックする。ベースラインは「正しい」と確認したうえで更新する。

### 25.3.4 まとめと次のステップ

- **25.0**: テストの目的・範囲、単体／結合／システム／リグレッションの階層、入力・期待値・合格基準の設計、テストデータとテストケースの体系、自動化方針を定める。
- **25.1**: 数値微分と解析的勾配の一致（T-grad-001～005）、CPU と GPU の同一入力での出力一致（T-match-001～005）で、実装の正しさを検証する。
- **25.2**: フレームバッファと勾配を画像・メッシュで可視化し、チェックリストと自動チェック（T-viz-001～003）で意図どおりの描画と勾配の分布を確認する。**nvdiffrast との比較検証**（25.2.3）では、共通入力・座標系変換・合格基準を定め、T-nv-001～004 で順方向・逆方向の一致を検証する。
- **25.3**: パフォーマンス測定（T-perf-001～005）とエッジケース（T-edge-001～010）を体系化し、実行順序と CI による自動化・リグレッションで性能と堅牢性を維持する。

ここまでで、第 22–24 章のフルスクラッチ実装が **正しく動き、CPU と GPU が一致し、性能とエッジケースが把握できている** 状態になる。その上で、テクスチャサンプリング・アンチエイリアシング・シルエット勾配の追加（第 6・7・11 章）や、より大きなメッシュ・解像度への最適化（第 24 章の拡張）に進むとよい。
