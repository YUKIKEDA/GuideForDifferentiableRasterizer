# 第14章 微分可能ラスタライザのコア

第 13 章で最小構成の CPU 実装と勾配の照合を学びました。本章では **微分可能ラスタライザのコア** を組み立てます。ソフトラスタライザの Python + PyTorch 実装（14.1）、解析的勾配（nvdiffrast 風）の導出と実装（14.2）、頂点位置・UV・法線への逆伝播の検証（14.3）、デバッグ手法（14.4）、そして **Deferred Interpolation（Rasterize-then-Interpolate）** のアーキテクチャ設計（14.5）を扱います。第 15 章の GPU 実装と第 17 章の nvdiffrast 解剖の土台になる章です。

---

## 14.1 ソフトラスタライザ（Python + PyTorch）の実装

### 14.1.1 設計の要点

第 10 章の定式化に沿い、**ピクセルごとの重み** をシグモイド・ソフトマックスで連続化します。

- **入力**: クリップ空間の頂点 `V_clip` 形状 `(N, 4)`、面 `F` 形状 `(M, 3)`、頂点属性（色・UV・法線など）。
- **順伝播**: 各ピクセルについて、全三角形（またはバウンディングボックス内の三角形）の「内側っぽさ」$m_t$ と深度 $d_t$ を計算し、$w_t \propto m_t \exp(-d_t/\tau)$ で正規化。色は $C = \sum_t w_t c_t$。
- **逆伝播**: $w_t$, $c_t$ は微分可能なので、`torch.autograd` またはカスタム `backward` で勾配を流す。

実装では、**全ピクセル×全三角形** のループは重いため、三角形の **バウンディングボックス** 内のピクセルだけを走査するか、PyTorch の **ベクトル化**（各ピクセルをバッチ次元で扱う）でまとめて計算します。

### 14.1.2 内側っぽさ $m_t$ の実装

エッジ関数 $E_{01}, E_{12}, E_{20}$ をスクリーン座標で計算し、シグモイドで連続化します。

```python
# 疑似: ピクセル q、頂点 p0,p1,p2（2D スクリーン）
def edge_fn(q, pi, pj):
    return (q[0]-pi[0])*(pj[1]-pi[1]) - (q[1]-pi[1])*(pj[0]-pi[0])
E01 = edge_fn(q, p0, p1)
E12 = edge_fn(q, p1, p2)
E20 = edge_fn(q, p2, p0)
# 内側っぽさ: 3 本とも正に近いほど 1
m = torch.sigmoid(alpha * E01) * torch.sigmoid(alpha * E12) * torch.sigmoid(alpha * E20)
```

$\alpha$ はハイパーパラメータ。$2A$ が小さい（退化）ときは $m=0$ とするなどガードを入れます。

### 14.1.3 深度のソフトマックスと色の合成

深度 $d_t$（手前ほど小さい値、例: NDC の $-z$）に対して、

```python
# 全三角形の重み（温度 tau）
log_w = m_t - d_t / tau   # 安定化のため d_t の最大値を引く
w = F.softmax(log_w, dim=-1)
C = (w * c_t).sum(dim=-1)  # ピクセル色
```

$c_t$ は三角形 $t$ のそのピクセルでの補間色（重心座標と透視補正で計算）。これで順伝播が定義でき、`C.backward(grad_output)` で $w_t$ と $c_t$ を通じて頂点・属性に勾配が流れます。

### 14.1.4 Custom Autograd Function にする場合

ラスタライザを **1 つの演算** として扱うには、`torch.autograd.Function` を継承し、`forward` と `backward` を実装します。

- **forward(ctx, V_clip, F, ...)**: 上記の順伝播を行い、フレームバッファ `C` を返す。`ctx.save_for_backward(...)` で重心座標・重み・深度などを保存。
- **backward(ctx, grad_output)**: `grad_output` は $\partial L/\partial C$。$w_t$ と $c_t$ の勾配を計算し、それらから頂点クリップ座標・属性への勾配を連鎖律で求め、`return (grad_V_clip, None, ...)` のように返す。

ソフトラスタでは $w_t$, $c_t$ がテンソル演算で書けているので、**中間テンソルを保存しておけば**、PyTorch の自動微分でそのまま backward が動く場合も多いです。必要に応じてカスタム Function にまとめると、のちに C++/CUDA に差し替えやすくなります（第 15 章）。

---

## 14.2 解析的勾配（nvdiffrast 風）の導出と実装

### 14.2.1 方針の整理

第 11 章の通り、**見えている三角形** についてだけ勾配を流します。

- **順伝播**: 通常のラスタライゼーション・深度テストで、各ピクセルに **1 つの三角形** とその **重心座標 $(u,v)$** が決まる。
- **逆伝播**: その三角形について、**補間式の微分**（第 6 章）で頂点スクリーン座標・$w$・属性への勾配を計算。さらに **スクリーン座標 → クリップ座標** は $w$ 除算の backward（第 6 章 6.6.2–6.6.4）でつなぐ。**境界ピクセル** では **シルエット勾配** を加算。

実装では、「どのピクセルにどの三角形が描かれたか」と「そのときの $(u,v)$, $1/w$, 属性」を **幾何バッファ** に保存し、backward でそれを使って勾配を計算します。

### 14.2.2 補間の backward

ピクセル $(i,j)$ に三角形 $t$ が描かれ、重心座標 $(u,v)$、補間色 $C$ が得られているとします。上流から $\partial L/\partial C$ が渡されたとき、

- $\frac{\partial L}{\partial u} = \frac{\partial L}{\partial C} \cdot \frac{\partial C}{\partial u}$（$C$ が線形補間なら $\frac{\partial C}{\partial u} = c_1 - c_0$ など）。
- $\frac{\partial L}{\partial v}$ も同様。
- 透視補正している場合は、第 6 章 6.6.3 の通り $A/w$, $1/w$ 経由で $\lambda_k$, $w_k$, $A_k$ への勾配を計算し、そこから $u$, $v$ と頂点属性への勾配を得る。

### 14.2.3 重心座標の頂点スクリーン座標に関する微分

第 6 章 6.3.2 の式をそのまま実装します。$u = E_{20}/(2A)$, $v = E_{01}/(2A)$ の $x_k$, $y_k$（頂点 $k$ のスクリーン座標）に関する偏微分を、保存した頂点スクリーン座標とピクセル位置から計算し、

$$
\frac{\partial L}{\partial x_k} = \frac{\partial L}{\partial u} \frac{\partial u}{\partial x_k} + \frac{\partial L}{\partial v} \frac{\partial v}{\partial x_k}
$$

で頂点スクリーン座標への勾配を得ます。同様に $y_k$。

### 14.2.4 クリップ座標への伝播

スクリーン座標は NDC の $x_c/w_c$, $y_c/w_c$ の線形写像なので、第 6 章 6.6.2 の **$w$ 除算の backward** を実装します。

- NDC の $x_{\text{NDC}} = x_c/w_c$ に対する勾配が、スクリーン座標の勾配から（線形写像の逆）得られる。
- $\frac{\partial L}{\partial x_c} = \frac{\partial L}{\partial x_{\text{NDC}}} \frac{1}{w_c}$, $\frac{\partial L}{\partial w_c}$ には $x_c$, $y_c$, $z_c$ の 3 つの除算からの寄与を加算。

これで **頂点のクリップ座標** $(x_c, y_c, z_c, w_c)$ への勾配が揃い、MVP の backward でモデル空間の頂点に伝播できます。

### 14.2.5 境界とシルエット勾配（概要）

境界ピクセルでは、隣接と三角形 ID が異なるなどの条件で検出し、**シルエット勾配** を加算します（第 11 章 11.5）。実装の詳細は Part VI 第 17 章に譲り、ここでは「境界では補間の勾配に加えて、エッジ・面積の頂点に関する微分を足す」とだけ押さえておけば十分です。最小実装では、まず **内部ピクセルだけ** で解析的勾配を動かし、境界は後から追加するのが現実的です。

---

## 14.3 頂点位置・UV・法線への逆伝播の検証

### 14.3.1 検証の流れ

1. **頂点位置**: 損失を 1 つ決め（例: 画像 L2 損失）、`loss.backward()` で `V.grad` を取得。数値勾配（第 13 章 13.4.3）と比較し、相対誤差が閾値以下であることを確認。
2. **UV**: テクスチャサンプリングまで含めたパイプラインで、UV を少し動かしたときの損失の変化と、`UV.grad` が一致するか確認。
3. **法線**: 法線補間・ライティングまで含め、法線属性の勾配を数値勾配と比較。

いずれも **離散的な切り替えが起きない範囲**（ピクセル帰属が変わらない、テクスチャのサンプル点が変わらない）で行うと、解析的勾配と数値勾配はよく一致します。

### 14.3.2 頂点位置の勾配チェック

```text
1. V を requires_grad=True で用意し、ラスタライザで画像 I を生成。
2. loss = (I - I_target).pow(2).sum(); loss.backward()
3. 1 頂点の 1 成分 v_i について、L_plus = loss(V の v_i を v_i+eps にしたとき)、L_minus = loss(v_i-eps)
4. 数値勾配 = (L_plus - L_minus) / (2*eps)
5. 相対誤差 = |V.grad[i] - 数値勾配| / (|数値勾配| + 1e-7) が十分小さいか確認
```

複数頂点・複数成分でサンプリングしてチェックすると、実装の抜け漏れを検出しやすくなります。

### 14.3.3 UV・法線の検証

UV は「補間 → テクスチャサンプリング」の入力なので、補間の backward とテクスチャの backward（第 8 章）が正しくつながっているかがポイントです。  
法線は補間 → 正規化 → ライティングなので、正規化の微分（第 8 章 8.2.1）が効いているか、同様に数値勾配で確認します。

---

## 14.4 デバッグ手法

### 14.4.1 勾配チェック（数値微分との比較）の体系的手法

- **スケジュール**: 頂点位置・UV・法線・カメラパラメータなど、**勾配を流す対象ごと** に 1 変数ずつ perturb して数値勾配を計算し、解析的勾配と比較する。
- **摂動の大きさ**: $\varepsilon$ を $10^{-5}$ から $10^{-2}$ 程度で変えて試す。小さすぎると桁落ち、大きすぎると打ち切り誤差が増える。
- **相対誤差と絶対誤差**: 数値勾配が 0 に近いときは絶対誤差だけでは不十分なので、相対誤差 $\frac{|\text{解析} - \text{数値}|}{|\text{数値}| + \epsilon}$ と、絶対誤差 $|\text{解析} - \text{数値}|$ の両方を見る。許容目安は相対誤差 $10^{-3}$ 以下など。
- **失敗したとき**: どの変数・どのピクセルでずれたかを特定し、その経路の backward の式（補間・重心座標・$w$ 除算）を再確認する。境界付近でずれる場合は、シルエット勾配やエッジ処理の有無を疑う。

### 14.4.2 可視化ツール（勾配マップ・アテンションマップ）

- **勾配マップ**: 頂点位置への勾配のノルムを、頂点ごとに色で可視化する。メッシュ上で「どの頂点が損失に敏感か」が分かる。勾配が 0 の頂点は、その視点から見えていないか、計算が途切れている可能性がある。
- **ピクセルごとの勾配**: $\partial L/\partial I_{i,j}$ を画像のように表示する。損失が強い領域（例: シルエットのずれ）で勾配が大きくなっているか確認できる。
- **アテンションマップ的な可視化**: 各ピクセルに「どの三角形が寄与したか」や「重心座標 $(u,v)$」を色で表示する。デバッグ時には、期待した三角形・期待した領域に重みが乗っているか確認する。

これらは実装の **正しさの確認** と、**学習がうまくいかない理由**（勾配が届いていない、境界でおかしい）の切り分けに有効です。

---

## 14.5 アーキテクチャ設計: Deferred Interpolation（Rasterize-then-Interpolate）

### 14.5.1 「幾何」と「属性」の分離

**Rasterize-then-Interpolate** では、処理を次の 2 段階に分けます。

1. **Rasterize**: 入力は頂点のクリップ座標（と面）。出力は **幾何バッファ** — 各ピクセルについて **三角形 ID**（または面 ID）、**重心座標 $(u,v)$**、**深度**（または $1/w$）。ここでは「どのピクセルにどの三角形が描かれるか」と「そのときの $(u,v)$」だけを決める。**属性（色・法線・UV）は使わない**。
2. **Interpolate**: 幾何バッファと **頂点属性** を入力に、各ピクセルで属性を補間（透視補正含む）し、**色・深度・法線・UV など** を出力する。

この分離により、**幾何**（三角形 ID・$(u,v)$）と **属性**（色・法線）が明確に区別され、勾配の導出と実装が整理されます（第 2 章 2.5.3、第 11 章 11.2）。

### 14.5.2 メモリ効率と微分のしやすさのメリット

- **メモリ**: 幾何バッファは「三角形 ID + $(u,v)$ + 深度」などで、属性テクスチャより小さい。異なる属性セット（色だけ、法線だけ）で **interpolate を複数回** 呼んでも、**rasterize は 1 回** で済む。逆に、rasterize の結果を捨てずに持っておけば、属性の種類を増やしても再ラスタライズ不要。
- **微分**: backward では「ピクセル勾配」を、まず **interpolate の backward** で「属性への勾配」と「$(u,v)$ への勾配」に分ける。$(u,v)$ への勾配は **rasterize の backward** に渡し、頂点位置（クリップ座標）への勾配を計算する。役割が分かれているので、式とコードの対応が分かりやすい。
- **G-buffer 的な考え方**: 従来の G-buffer は「ジオメトリ情報をいったんバッファに書き、後段でシェーディング」する方式。Rasterize-then-Interpolate は、その「ジオメトリ＝三角形 ID・重心座標」に相当する部分を明示し、微分可能にしたものと見なせます。Part VI 第 17 章で nvdiffrast の API がまさに `rasterize` と `interpolate` に分かれていることを学びます。

### 14.5.3 実装上のインターフェース例

```text
# 順伝播
geom = rasterize(V_clip, F, resolution)   # -> tri_id, u, v, depth, 1/w など
color = interpolate(geom, vertex_colors) # -> 色画像
normal = interpolate(geom, vertex_normals) # -> 法線画像（必要なら）

# 逆伝播
grad_vertex_colors = interpolate_backward(geom, grad_color)
grad_V_clip += rasterize_backward(geom, grad_u, grad_v, ...)
```

`geom` を共通の中間表現として持つことで、属性の追加・削除や、デバッグ時の「幾何だけ固定して属性だけ変える」といった操作がしやすくなります。

---

## 14.6 まとめと次章への接続

- **ソフトラスタ**: シグモイドで内側っぽさ、ソフトマックスで深度重み。PyTorch でベクトル化し、必要なら Custom Function にまとめる。勾配は自動微分または手で backward。
- **解析的勾配**: 見えている三角形だけに補間の微分＋重心座標の頂点微分＋$w$ 除算の backward。境界ではシルエット勾配を加算。幾何バッファに三角形 ID・$(u,v)$ を保存して backward で再利用。
- **検証**: 頂点位置・UV・法線について、数値勾配との比較で勾配チェック。離散切り替えのない範囲で一致を確認。
- **デバッグ**: 勾配チェックの手順を体系化し、勾配マップ・ピクセル勾配・寄与の可視化で問題箇所を特定する。
- **Deferred Interpolation**: Rasterize（幾何）と Interpolate（属性）を分離。メモリと微分の整理、G-buffer 的な設計。nvdiffrast（第 17 章）の API 設計の布石。

次章（第 15 章）では **GPU 実装の基礎** に進み、CUDA/Metal の基本、並列ラスタライゼーション、アトミック操作と深度ソート、PyTorch との連携（custom op）、プロファイリングとビルドエコシステムを学びます。本章の Python 実装を、GPU カーネルと拡張に発展させる準備になります。

---

*前: [第 13 章 最小構成の CPU 実装](Chapter13.md) | 次: [第 15 章 GPU 実装の基礎](Chapter15.md)*
