# 第12章 実装上の考慮事項

Part V は **実装編** です。第 11 章までで理論を押さえたので、ここからはスクラッチで微分可能ラスタライザを実装する際の **考慮事項** を整理します。本章では、**退化三角形・背面・クリッピング**（12.1）、**数値安定性**（スケーリング・ログ空間）（12.2）、**メモリと計算コストのトレードオフ**（12.3）を扱います。第 13–14 章で具体的なコードに進む前に、これらの落とし穴と設計選択を頭に入れておくと、デバッグと拡張が楽になります。

---

## 12.1 退化三角形・背面・クリッピング

### 12.1.1 退化三角形

**退化三角形**（degenerate triangle）とは、面積が 0 の三角形です。3 頂点が一直線上に並んでいるか、同一の点が重なっている場合に起こります。

- **原因**: メッシュの生成・変形・LOD の切り替え、あるいは最適化の途中で頂点が重なったとき。
- **問題**: 符号付き面積 $2A$ が 0 になると、重心座標 $u = E_{20}/(2A)$, $v = E_{01}/(2A)$ が **0 除算** で定義できない。エッジ関数の値も 0 になり、内外判定が曖昧になる。
- **対処**:
  - **事前に除去**: ラスタライザに渡す前に、面積が閾値未満の三角形をスキップする。
  - **ガード**: $2A$ が十分小さいときはその三角形を描画しない、または重心座標をデフォルト値にクリップして除算を避ける。
  - **勾配**: 退化三角形には勾配を流さない（または 0 とする）。そうしないと、$1/(2A)$ が爆発して数値が不安定になる。

実装では、`abs(2A) < epsilon` のようなチェックを入れ、該当する三角形は early-out するのが安全です。

### 12.1.2 背面カリング

**背面** とは、カメラから見て法線が「こちらを向いていない」面です。多くのパイプラインでは描画をスキップします。

- **判定**: 頂点の並び順（winding order）と、スクリーン空間でのエッジの符号で判定。反時計回りが表とすれば、符号付き面積 $2A < 0$ なら背面。
- **微分可能ラスタライザでの選択**:
  - **カリングする**: 背面には勾配を流さない。形状最適化では「表だけ見える」前提で十分なことが多い。
  - **カリングしない**: 両面に勾配を流す。薄い板や裏側も最適化対象にする場合に有効。計算コストは増える。

API や用途に応じて、背面を描画するか・勾配を流すかをオプションで切り替えられるようにしておくと便利です。

### 12.1.3 クリッピング

**クリッピング** は、視錐台の外にある図形を切り取る処理です。三角形が視錐台をまたぐ場合、クリップ後に **新しい頂点** が生じ、三角形が複数の小三角形に分割されることがあります。

- **問題**: クリップ後の頂点は **元の頂点の線形結合** なので、勾配は元の頂点に按分して戻せる。ただし実装が複雑になる（ Sutherland–Hodgman など）。
- **簡易策**: クリッピングをせず、**NDC の範囲外** の三角形は描画しない（カリング）。完全に外ならスキップ、一部だけ見える場合はクリップせずにそのままラスタライズすると、はみ出した部分が描画されるが、多くの逆レンダリングでは「画面内の見え方」が主な目的なので、簡易策で十分なことが多い。
- **本格実装**: nvdiffrast などでは、クリッピングを正しく行い、クリップで生成された頂点にも属性と勾配を伝播させる。Part VI で触れる。

まずは「範囲外はスキップ」で動かし、必要になったらクリッピングを追加する、という段階的な設計が現実的です。

---

## 12.2 数値安定性（スケーリング・ログ空間）

### 12.2.1 除算とオーバーフロー・アンダーフロー

ラスタライザでは **除算** が多く現れます。

- **重心座標**: $u = E_{20}/(2A)$, $v = E_{01}/(2A)$。$2A$ が非常に小さいと $u$, $v$ が爆発する。
- **透視補正**: $A = (A/w)/(1/w)$。$1/w$ が 0 に近い（奥の頂点）と、補間結果が不安定になる。
- **深度のソフトマックス**（ソフトラスタ）: $\exp(-d/\tau)$ は $d$ が極端なときオーバーフロー・アンダーフローする。

**対処**:
- 分母が閾値未満のときは除算を行わない（スキップまたはクリップ）。
- ソフトマックスでは **最大値を引く** テクニック: $\exp(x_i - \max_k x_k)$ で正規化すると安定する（第 10 章 10.4.3）。

### 12.2.2 スケーリング

座標の **スケール** が極端だと、エッジ関数 $E_{ij}$ や面積 $2A$ の絶対値が大きくなりすぎたり小さくなりすぎたりします。

- **問題**: float32 では有効桁数に限りがある。画面全体が 1 ピクセル程度の大きさで描かれるような遠い三角形では、スクリーン座標の差が量子化され、勾配がおかしくなることがある。
- **対処**:
  - クリップ空間やスクリーン座標の **スケールを適切に保つ**（カメラの near/far や解像度の設定）。
  - エッジ関数や面積を **スケールで正規化** する、あるいは相対的な閾値（$2A$ が辺の長さの 2 乗の何倍か）で判定する。

### 12.2.3 ログ空間

**積** や **比** を扱うとき、**ログ空間** で計算するとアンダーフローを防げます。

- 例: ソフトラスタで複数の「内側っぽさ」の積 $w = \prod_k \sigma(\alpha E_k)$ を取る場合、$\log w = \sum_k \log \sigma(\alpha E_k)$ とし、最後に $\exp(\log w)$ で $w$ を復元する。
- 比 $a/b$ は $\exp(\log a - \log b)$ として計算できる。$a$, $b$ が非常に小さいときでも、$\log a$, $\log b$ は有限なので、差を取ってから exp すれば安定する場合がある。

勾配も、$\log w$ を変数として連鎖律を適用すれば、ログ空間上で一貫した backward が書けます。

### 12.2.4 イプシロンと閾値

- **0 除算の回避**: `2A` に対して `eps = 1e-7` 程度の閾値を用意し、`abs(2A) < eps` ならその三角形をスキップする。
- **エッジ上の判定**: ピクセル中心がエッジ上にある場合、浮動小数点の誤差で「内」「外」が振れないよう、内外判定に **緩い閾値**（例: $E \ge -\varepsilon$ を内側とみなす）を入れることがある。ただし、勾配の定義と整合させる必要がある（Part VI 18.6）。
- **勾配のクリッピング**: 逆伝播で得た勾配が異常に大きい場合、ノルムでクリップして爆発を防ぐ。オプティマイザ側で行うこともある。

---

## 12.3 メモリと計算コストのトレードオフ

### 12.3.1 フレームバッファと深度バッファ

- **解像度** $W \times H$ に対して、色バッファは $O(WH)$、深度バッファも $O(WH)$。float32 で 4 チャンネルなら $16WH$ バイト程度。
- **勾配**: 逆伝播では **同じサイズの勾配バッファ** が必要。色・深度それぞれについて $\partial L / \partial (\text{pixel})$ を保持する。メモリは順伝播の約 2 倍（出力と勾配）。

### 12.3.2 幾何バッファ（G-buffer 的）

**Rasterize-then-Interpolate**（第 11 章、第 14 章 14.5）では、ラスタライザの出力として次を保持します。

- 各ピクセルに **三角形 ID**（または面 ID）
- **重心座標** $(u, v)$ または $(b_0, b_1, b_2)$
- **深度** $z$ や $1/w$

この **幾何バッファ** を保存しておくと、interpolate の段階で属性（色・法線・UV）を補間し、逆伝播では「幾何」と「属性」を分けて勾配を計算できます。  
**トレードオフ**: 幾何バッファを保存するか、毎回再計算するか。保存するとメモリが増えるが、interpolate を複数回（異なる属性で）呼ぶときにラスタライズは 1 回で済む。nvdiffrast はこの分離を採用しています。

### 12.3.3 頂点・面の数と計算量

- **頂点数** $V$、**面数** $F$: ラスタライザは通常、三角形ごとにループするか、ピクセルごとにループする。三角形並列なら $O(F)$ の並列度、ピクセル並列なら $O(WH)$。
- **勾配の蓄積**: 各頂点に勾配を **加算** するため、同じ頂点を参照する複数ピクセルからの勾配が 1 か所に集まる。メモリは頂点あたり $O(1)$、ただし **アトミック加算** や **重複頂点**（UV は違うが位置は同じ）の扱いが GPU では重要（Part V 第 15 章、Part VI 17.6）。

### 12.3.4 バッチと解像度

- **バッチ**: 複数画像を同時にレンダリングする場合、バッチ次元を追加するとメモリが `B * W * H * ...` になる。バッチサイズと解像度の積が GPU メモリに収まるか確認する。
- **マルチ解像度**: 学習では低解像度で重くて高解像度で軽い、といった段階的なスケジュールが使われることがある。実装では解像度を引数で切り替えられるようにしておくと便利。

---

## 12.4 まとめと次章への接続

- **退化・背面・クリッピング**: 退化三角形は面積 0 で除算が起きるのでスキップまたはガード。背面はカリングするか両面描画するかをオプションで。クリッピングは簡易的には「範囲外スキップ」、本格化するとクリップ頂点への勾配の按分が必要。
- **数値安定性**: 除算のガード、ソフトマックスの最大値引き、スケーリングの見直し、ログ空間の利用、イプシロンと閾値で 0 除算・エッジ判定・勾配爆発を防ぐ。
- **メモリとコスト**: フレーム・深度・勾配バッファのサイズ、幾何バッファの有無、頂点勾配の蓄積、バッチと解像度のトレードオフを意識する。

次章（第 13 章）では **最小構成の CPU 実装** に進み、頂点変換（MVP）の実装と微分、単一三角形のラスタライズ（エッジ関数・重心座標）、深度バッファとフレームバッファ、そして勾配の手計算と autograd との照合を学びます。本章の考慮事項を踏まえつつ、まずは小さいコードで全体の流れを掴みます。

---

*前: [第 11 章 サブディビジョンと解析的勾配](../Part04/Chapter11.md) | 次: [第 13 章 最小構成の CPU 実装](Chapter13.md)*
