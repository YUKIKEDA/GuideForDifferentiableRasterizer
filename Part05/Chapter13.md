# 第13章 最小構成の CPU 実装

第 12 章で実装上の考慮事項を押さえました。本章では **最小構成の CPU 実装** を通じて、微分可能ラスタライザの流れを具体化します。頂点変換（MVP）の実装と微分（13.1）、単一三角形のラスタライズ（エッジ関数・重心座標）（13.2）、深度バッファとフレームバッファ（13.3）、そして勾配の手計算と autograd との照合（13.4）を扱います。複数三角形・GPU・ソフト/解析的勾配は第 14 章以降に譲り、ここでは **1 三角形・CPU・順伝播と逆伝播の検証** に絞ります。

---

## 13.1 頂点変換（MVP）の実装と微分

### 13.1.1 入出力の形

- **入力**: 頂点位置 `V` 形状 `(N, 3)` または `(N, 4)`（同次座標）、面インデックス `F` 形状 `(M, 3)`。カメラの射影行列 `P`、ビュー行列 `V_mat`、モデル行列 `M`（いずれも `(4, 4)`）。
- **出力**: クリップ空間の頂点 `V_clip` 形状 `(N, 4)`。各頂点は `(x_c, y_c, z_c, w_c)`。

最小構成では、モデル行列を単位行列、ビュー行列を簡単な平行移動・回転にし、**透視射影行列** だけを正しく実装するのがよいです。

### 13.1.2 透視射影行列の例

近クリップ $n$、遠クリップ $f$、縦横比 $a$、垂直視野角 $\mathrm{fovy}$ のとき、よく使う透視行列（列ベクトル・右手系）の形は次のとおりです。

$$
\mathbf{P} = \begin{pmatrix}
\frac{1}{a \tan(\mathrm{fovy}/2)} & 0 & 0 & 0 \\
0 & \frac{1}{\tan(\mathrm{fovy}/2)} & 0 & 0 \\
0 & 0 & \frac{f+n}{f-n} & -\frac{2fn}{f-n} \\
0 & 0 & 1 & 0
\end{pmatrix}
$$

最後の行が $(0, 0, 1, 0)$ なので、同次座標の $w_c$ は **カメラ空間の $-z$**（深度）になります。  
実装では、`V_h = (x,y,z,1)` とし、`V_clip = (P @ V_view.T).T` のように行列積でクリップ座標を求めます。PyTorch では `torch.matmul(V_clip, P.T)` など、バッチ次元に合わせてブロードキャストします。

### 13.1.3 微分

MVP は **線形**（同次座標では行列積）なので、逆伝播は「上流の勾配に転置行列を掛ける」だけです。

- 順伝播: $\mathbf{v}_{\text{clip}} = \mathbf{P} \mathbf{M}_{\text{view}} \mathbf{M}_{\text{model}} \mathbf{v}$。
- 逆伝播: $\frac{\partial L}{\partial \mathbf{v}} = \mathbf{M}_{\text{model}}^\top \mathbf{M}_{\text{view}}^\top \mathbf{P}^\top \frac{\partial L}{\partial \mathbf{v}_{\text{clip}}}$。

PyTorch で `V` に `requires_grad=True` を付け、`V_clip = (P @ V.T).T` のように書けば、`V_clip.backward(grad_output)` で `V.grad` に勾配が入ります。**カメラパラメータ**（P の要素）も最適化する場合は、P をテンソルにして同様に勾配を流せます。

---

## 13.2 単一三角形のラスタライズ（エッジ関数・重心座標）

### 13.2.1 クリップ座標から NDC・スクリーン座標へ

3 頂点のクリップ座標を `(x_c, y_c, z_c, w_c)_k`（$k=0,1,2$）とします。

- **NDC**: $x_{\text{NDC}} = x_c / w_c$, $y_{\text{NDC}} = y_c / w_c$, $z_{\text{NDC}} = z_c / w_c$。
- **スクリーン座標**（解像度 $W \times H$）: 例として $x_s = (W/2)(1 + x_{\text{NDC}})$, $y_s = (H/2)(1 - y_{\text{NDC}})$。$y$ を反転するかは API に合わせます。

ピクセル $(i, j)$ の中心は $(i + 0.5, j + 0.5)$ とします。

### 13.2.2 エッジ関数と内外判定

第 6 章の式を使います。スクリーン座標で 3 頂点を $\mathbf{p}_0, \mathbf{p}_1, \mathbf{p}_2$（反時計回り）、ピクセル中心を $\mathbf{q} = (x, y)$ とすると、

$$
E_{01}(\mathbf{q}) = (x - x_0)(y_1 - y_0) - (y - y_0)(x_1 - x_0)
$$
$$
E_{12}(\mathbf{q}) = (x - x_1)(y_2 - y_1) - (y - y_1)(x_2 - x_1)
$$
$$
E_{20}(\mathbf{q}) = (x - x_2)(y_0 - y_2) - (y - y_2)(x_0 - x_2)
$$

**内外判定**: $E_{01} \ge 0$ かつ $E_{12} \ge 0$ かつ $E_{20} \ge 0$ なら三角形の内側（または辺上）。  
**符号付き面積の 2 倍**: $2A = E_{12}(\mathbf{p}_0)$。退化チェックとして `abs(2A) < eps` ならスキップします。

### 13.2.3 重心座標

$$
u = \frac{E_{20}(\mathbf{q})}{2A}, \quad v = \frac{E_{01}(\mathbf{q})}{2A}, \quad b_0 = 1 - u - v
$$

単一三角形のみを描く場合は、この $(u, v)$ で属性（色・深度）を補間します。透視補正する場合は、$1/w$ と 属性$/w$ を線形補間してから $A = (A/w)/(1/w)$ で復元（第 6 章）。

### 13.2.4 ループの形（CPU）

```text
for j in 0 .. H:
  for i in 0 .. W:
    q = (i + 0.5, j + 0.5)
    E01, E12, E20 = edge_functions(q, p0, p1, p2)
    if E01 >= 0 and E12 >= 0 and E20 >= 0:
      inv_2A = 1.0 / (2*A)   # 2A は事前に計算、ゼロチェック済み
      u = E20 * inv_2A
      v = E01 * inv_2A
      # 深度・色を補間し、深度テストのうえでフレームバッファに書き込み
```

エッジ関数と $2A$ は頂点のスクリーン座標の関数なので、PyTorch でテンソルとして書けば、このループ全体を **ベクトル化** するか、あるいは 1 ピクセルだけ取り出して `backward` で勾配を確認できます。

---

## 13.3 深度バッファとフレームバッファ

### 13.3.1 深度の補間

単一三角形では深度テストは不要ですが、のちに複数三角形に対応するときのために、**深度** を補間してバッファに書く形にします。

- NDC の $z$ を頂点で持つか、$z/w$ と $1/w$ を透視補正で補間して $z = (z/w)/(1/w)$ を得る。
- 深度バッファ `depth_buf[i,j]` には、現在のピクセルでの深度を書き、**手前**（小さい値）を残すか **奥**（大きい値）を残すかは API に合わせます。最小構成では「今の三角形の深度」をそのまま書けばよいです。

### 13.3.2 フレームバッファ（色）

頂点色 $\mathbf{c}_0, \mathbf{c}_1, \mathbf{c}_2$ を、重心座標 $(u, v)$ で補間（透視補正する場合は $1/w$ と $\mathbf{c}/w$ を線形補間）して、ピクセル色 $\mathbf{c}$ を得ます。  
`color_buf[i, j] = c` のように書き込みます。単一三角形なら上書きで十分です。

### 13.3.3 バッファの初期化

- 深度バッファ: 遠クリップの値（奥を残す場合）または近クリップの値（手前を残す場合）で初期化。
- フレームバッファ: 背景色（例: 0）で初期化。

勾配を考えるときは、**どのピクセルに何が描かれたか** と **そのときの $(u, v)$** を記録しておき、逆伝播で「そのピクセルの損失の勾配」を補間式の backward に渡します。

---

## 13.4 勾配の手計算と autograd との照合

### 13.4.1 逆伝播で必要なもの

損失 $L$ が「画像の各ピクセル」の関数だとします（例: $L = \sum_{i,j} (I_{i,j} - I_{\text{target},i,j})^2$）。逆伝播では、

1. $\frac{\partial L}{\partial I_{i,j}}$ が与えられる（上流から）。
2. ピクセル $(i,j)$ に三角形が描かれていれば、そのピクセルの色 $I_{i,j}$ は補間色 $C(u,v)$。したがって $\frac{\partial L}{\partial u}$, $\frac{\partial L}{\partial v}$ が必要。
3. $u$, $v$ は頂点のスクリーン座標の関数（第 6 章 6.3.2）。スクリーン座標は NDC の $w$ 除算の結果なので、第 6 章 6.6 の連鎖で **頂点のクリップ座標** まで勾配を戻す。

### 13.4.2 手計算で確認するポイント

- **MVP の勾配**: クリップ座標の勾配 `d_v_clip` が得られたとき、`d_V = (d_v_clip @ P.T)` のようにして頂点位置の勾配を計算。PyTorch の `autograd` で `V_clip = V @ P.T` として `V_clip.backward(...)` を実行し、`V.grad` と手計算を比較する。
- **重心座標の勾配**: 1 ピクセルだけに注目し、$\frac{\partial u}{\partial x_0}$, $\frac{\partial u}{\partial y_0}$ などを第 6 章の式で手計算。PyTorch で `u`, `v` を頂点のスクリーン座標の関数として定義し、`u.backward()` で得た勾配と照合する。
- **補間色の勾配**: $C = (1-u-v)c_0 + u c_1 + v c_2$ なら $\frac{\partial C}{\partial u} = c_1 - c_0$, $\frac{\partial C}{\partial v} = c_2 - c_0$。上流から $\frac{\partial L}{\partial C}$ が渡されたとき、$\frac{\partial L}{\partial u} = \frac{\partial L}{\partial C} \cdot (c_1 - c_0)$ など。これも autograd と一致するか確認する。

### 13.4.3 数値勾配との比較（勾配チェック）

小さな $\varepsilon$ で、1 つの頂点の 1 成分だけを $v_i \to v_i + \varepsilon$ と $v_i - \varepsilon$ に動かし、$L$ の変化から中心差分で数値勾配を計算します。

$$
\frac{\partial L}{\partial v_i} \approx \frac{L(v_i + \varepsilon) - L(v_i - \varepsilon)}{2\varepsilon}
$$

解析的（または autograd）の勾配と、相対誤差や桁数で比較します。**離散的な切り替えが起きない範囲**（ピクセル帰属が変わらない）で行うと、数値勾配と解析的勾配はよく一致します。境界付近ではずれることがあるので、そのときは「境界用のシルエット勾配」を実装する段階（第 14 章）で再度検証します。

### 13.4.4 最小構成のまとめ

- MVP → クリップ座標は行列積で、autograd で勾配が流れる。
- ラスタライズは「エッジ関数 → 内外判定 → 重心座標」の順。単一三角形なら、内側のピクセルについて $(u, v)$ と補間色・深度を計算し、バッファに書く。
- 逆伝播は「ピクセル勾配 → 補間の $u,v$ 勾配 → 重心座標の頂点スクリーン座標に関する微分 → $w$ 除算の backward → クリップ座標の勾配 → MVP の backward」とつなぐ。
- 手計算と autograd、数値勾配との照合で、最小ルートの勾配が正しいことを確認する。

---

## 13.5 まとめと次章への接続

- **MVP**: 透視射影行列でクリップ座標を計算。線形なので逆伝播は転置行列。PyTorch では `requires_grad` でそのまま検証できる。
- **単一三角形ラスタライズ**: エッジ関数 $E_{01}, E_{12}, E_{20}$ で内外判定、$u = E_{20}/(2A)$, $v = E_{01}/(2A)$ で重心座標。深度・色を補間して深度バッファ・フレームバッファに書き込む。
- **勾配の照合**: 補間式の $u,v$ 勾配、重心座標の頂点に関する微分、MVP の勾配を手計算または autograd で確認。数値勾配との比較で勾配チェックする。

次章（第 14 章）では **微分可能ラスタライザのコア** に進み、ソフトラスタライザ（Python + PyTorch）の実装、解析的勾配（nvdiffrast 風）の導出と実装、頂点位置・UV・法線への逆伝播の検証、デバッグ手法、そして Rasterize-then-Interpolate のアーキテクチャ設計を学びます。本章の最小構成を土台に、複数三角形・ソフト/解析的勾配・本格的な backward を組み立てます。

---

*前: [第 12 章 実装上の考慮事項](Chapter12.md) | 次: [第 14 章 微分可能ラスタライザのコア](Chapter14.md)*
