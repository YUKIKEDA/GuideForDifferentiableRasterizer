# 第16章 本格的なパイプライン

第 15 章で GPU 実装の基礎とビルドを学びました。本章では **本格的なパイプライン** を組み上げます。メッシュ入力（頂点・面・UV・法線）の扱い（16.1）、バッチ処理とマルチ解像度（16.2）、テクスチャサンプリングの微分可能実装（16.3）、アンチエイリアシングの組み込み（16.4）、半透明・ブレンディング（アルファ合成と勾配）（16.5）、そしてテストとベンチマーク（nvdiffrast との比較）（16.6）を扱います。Part VI で nvdiffrast を解剖する前に、自作パイプラインを「本番に近い形」まで持っていく章です。

---

## 16.1 メッシュ入力（頂点・面・UV・法線）の扱い

### 16.1.1 入力形式の統一

実用では、メッシュは **OBJ・FBX・glTF** など様々な形式で渡されます。微分可能ラスタライザの内部では、次の形に揃えると扱いやすいです。

- **頂点位置** `V`: 形状 `(N, 3)` または `(N, 4)`（同次）。モデル空間またはワールド空間。float32。
- **面インデックス** `F`: 形状 `(M, 3)`。各行が 1 三角形の 3 頂点インデックス。int32 または long。
- **頂点 UV** `VT` または `uv`: 形状 `(N, 2)`。頂点ごとに 1 組の UV。メッシュによっては **頂点と UV が 1:1 でない**（同じ位置に複数 UV）ことがあるので、その場合は「頂点」を「位置＋UV」の組として拡張する（第 17 章 17.6）。
- **頂点法線** `VN` または `normals`: 形状 `(N, 3)`。正規化されていることを前提にするか、補間前に正規化する。
- **頂点色**（任意）: 形状 `(N, 3)` または `(N, 4)`。

OBJ では `v`, `vt`, `vn`, `f` で定義され、`f` は `v/vt/vn` の組を指定します。1 つの面で位置・UV・法線のインデックスが異なる場合、**頂点を展開**（同じ位置を複数頂点として持つ）して、各面で独立した UV・法線を持たせる実装が一般的です。

### 16.1.2 パイプラインへの投入

- **MVP 変換**: `V` をモデル・ビュー・射影でクリップ空間に写す。法線は **法線行列**（モデル行列の逆転置の 3×3 部分）で変換する。UV はそのまま（または別途変換する場合のみ変更）。
- **ラスタライザへの入力**: クリップ空間の `V_clip` と `F` が必須。interpolate 段階では、`V_clip` に加えて UV・法線・頂点色などの属性テンソルを渡す。
- **デバイス**: すべて GPU 上に置く場合は `.to(device)` で統一。バッチの場合も `(B, N, 3)` などバッチ次元を先頭に揃える。

### 16.1.3 重複頂点と勾配のマージ

「位置は同じだが UV が異なる頂点」が別インデックスで存在する場合、**位置** への勾配は **同じ位置を共有する全頂点** に **加算** して渡す必要があります（Part VI 17.6）。実装では、頂点インデックスから「位置の共有グループ」を事前に計算し、backward で位置勾配をグループごとに集約してから、そのグループに属する頂点に同じ勾配を配る、といった形にします。

---

## 16.2 バッチ処理とマルチ解像度

### 16.2.1 バッチ処理

**バッチ** では、複数のメッシュ（または複数カメラ・複数フレーム）を同時にレンダリングします。

- **入力**: 頂点 `(B, N, 3)`、面は共通 `(M, 3)` か、バッチごと `(B, M, 3)`。カメラはバッチごとに `(B, 4, 4)` の射影行列など。
- **出力**: 色画像 `(B, H, W, C)`、深度 `(B, H, W)`、必要なら幾何バッファも `(B, H, W, ...)`。
- **メモリ**: バッチ次元が大きいと GPU メモリを圧迫する。バッチサイズと解像度の積を抑えるか、勾配を蓄積するなどして実質的なバッチを大きくする。

ラスタライザの forward/backward を **バッチ次元でループ** するか、カーネル内で `blockIdx` の一軸をバッチに割り当てて並列化するかは実装次第です。nvdiffrast はバッチをサポートしています。

### 16.2.2 マルチ解像度

**マルチ解像度** では、解像度を引数で切り替え、学習の段階や用途に応じて使い分けます。

- **低解像度**: 初期学習・粗い最適化で高速に試す。勾配は荒いが反復回数を増やしやすい。
- **高解像度**:  fine-tuning や評価で、細部と勾配の質を上げる。
- **実装**: `resolution=(W, H)` を API に渡し、フレームバッファ・深度バッファ・幾何バッファのサイズをすべてその解像度に合わせる。マルチ解像度用に別の損失（例: マルチスケール L1）を組み合わせることもある。

第 17 章では、nvdiffrast のマルチ解像度とミップマップの関係にも触れます。

---

## 16.3 テクスチャサンプリングの微分可能実装

### 16.3.1 パイプライン内の位置づけ

第 8 章で学んだように、**補間された UV** でテクスチャをサンプリングし、ピクセル色を得ます。本格パイプラインでは、

1. **Rasterize**: 幾何バッファ（三角形 ID・重心座標 $(u,v)$）を出力。
2. **Interpolate**: UV を補間してピクセルごとの $(u,v)_{\text{frag}}$ を得る。
3. **Texture sample**: $(u,v)_{\text{frag}}$ でテクスチャをサンプリングし、色を得る。

3 は **微分可能** である必要があります。双線形補間でサンプリングし、**UV への勾配** と **テクセルへの勾配** を backward で計算します（第 8 章 8.3）。

### 16.3.2 PyTorch との連携

PyTorch の `F.grid_sample` は、正規化座標のグリッドでテクスチャをサンプリングでき、`mode='bilinear'` で微分可能です。UV を `(-1,1)` の範囲に正規化して `grid` を組み、`grid_sample(texture, grid)` でピクセル色を得ます。backward は自動で流れ、テクスチャと UV の両方に勾配が伝わります。  
自作 CUDA でテクスチャサンプリングを書く場合は、第 8 章の双線形の式と backward をそのまま実装し、interpolate の出力（UV 画像）とテクスチャを入力にした custom op にします。

### 16.3.3 Mipmap の扱い

第 8 章 8.4 の通り、**LOD を固定** して、サンプリングに使ったレベルだけを微分するのが現実的です。高解像度テクスチャでは、勾配のメモリと更新範囲（どの Mip レベルまで更新するか）のトレードオフを設計で決めます。

---

## 16.4 アンチエイリアシングの組み込み

### 16.4.1 組み込みの選択肢

第 7 章で学んだアンチエイリアシングを、本格パイプラインにどう入れるかを決めます。

- **MSAA**: ハードウェア支援がある環境では有効。微分可能ラスタライザでは、サンプルごとの 0/1 が残るため、勾配は「カバレッジ」の連続近似か、解析的 AA と併用する形になる。
- **解析的 AA**: ピクセルと三角形の **重なり面積** を式で計算し、境界で滑らかにブレンドする。順伝播と逆伝播を同じ式で定義できるため、勾配の一貫性が取りやすい（第 11 章 11.3）。nvdiffrast はオプションで解析的 AA を提供している（第 17 章）。

まずは **AA なし** で動かし、必要に応じて **解析的 AA** を境界ピクセルにだけ適用する、という段階的組み込みが現実的です。

### 16.4.2 境界ピクセルとシルエット勾配

解析的 AA を入れる場合、**境界ピクセル** の検出と、そのピクセルでの **面積に基づく重み** および **シルエット勾配** を、第 11 章・第 14 章の設計に沿って実装します。境界では、補間の勾配に加えて面積の頂点に関する微分を加算し、輪郭を動かす学習ができるようにします。

### 16.4.3 パフォーマンス

解析的 AA は全ピクセルで重なり面積を計算すると重いため、**エッジに隣接するピクセルだけ** に限定する、または低解像度では AA をオフにする、といった切り替えがあると運用しやすいです。

---

## 16.5 半透明・ブレンディング（アルファ合成と勾配）

### 16.5.1 アルファブレンディング

**半透明** を扱うには、複数三角形が同一ピクセルに寄与するとき、**奥から手前** の順に **アルファ合成** します。

$$
C_{\text{out}} = \alpha_{\text{new}} C_{\text{new}} + (1 - \alpha_{\text{new}}) C_{\text{in}}
$$

$C_{\text{in}}$ はすでに描画された色、$C_{\text{new}}$ と $\alpha_{\text{new}}$ はこれから描くフラグメントの色と不透明度です。深度順にソートしたうえで、この式を順に適用します。

### 16.5.2 微分可能性

アルファ合成は **線形**（$C_{\text{out}}$ は $C_{\text{new}}$ と $C_{\text{in}}$ の線形結合）なので、式の上では微分可能です。逆伝播では、

- $\frac{\partial L}{\partial C_{\text{out}}}$ が与えられたとき、$\frac{\partial L}{\partial C_{\text{new}}} = \alpha_{\text{new}} \frac{\partial L}{\partial C_{\text{out}}}$、$\frac{\partial L}{\partial C_{\text{in}}} = (1-\alpha_{\text{new}}) \frac{\partial L}{\partial C_{\text{out}}}$ と配分する。
- $\alpha_{\text{new}}$ にも勾配を流す場合は、$\frac{\partial C_{\text{out}}}{\partial \alpha_{\text{new}}} = C_{\text{new}} - C_{\text{in}}$ を掛けて渡す。

**深度の順序** が変わると合成の式が変わるため、境界（深度が同じ付近）では勾配が不連続になり得ます。ソフトな深度重み（ソフトラスタ的）にすると連続になるが、その分だけ「ハードな半透明」ではなくなります。

### 16.5.3 実装の注意

半透明対応では、各ピクセルに **複数フラグメント** を保持し、深度ソートしてからアルファ合成する必要があります。メモリと計算コストが増えるため、**フラグメント数の上限** を設けるか、半透明をオプションにして、不透明だけのパスと切り替えられるようにするのが無難です。

---

## 16.6 テストとベンチマーク（nvdiffrast との比較）

### 16.6.1 正しさのテスト

- **参照実装との一致**: 同じメッシュ・同じカメラで **nvdiffrast** と自作ラスタライザの **順伝播の出力**（色画像・深度）を比較する。数値誤差（L2 や相対誤差）が許容範囲か確認する。座標系・クリップ・NDC の定義が一致していることが前提。
- **勾配の一致**: 同じ入力で `loss.backward()` したときの **頂点位置・UV・法線の勾配** を、nvdiffrast と自作で比較する。数値勾配との比較（第 14 章）に加え、参照実装との一致で実装の正しさを補強できる。

### 16.6.2 ベンチマーク

- **速度**: 同一解像度・同一メッシュで、順伝播＋逆伝播の **所要時間** を計測する。バッチサイズを変えたときのスループット（枚数/秒）も記録するとよい。
- **メモリ**: ピーク GPU メモリ使用量を、解像度・メッシュサイズ・バッチサイズごとに計測する。nvdiffrast は最適化されているため、自作は同じ条件で遅い・メモリを多く使うことが多いが、**どこがボトルネックか** をプロファイラで確認し、改善の指針にする。

### 16.6.3 レグレッション防止

- **ユニットテスト**: 小さな三角形・単純なシーンで、順伝播の出力と勾配を **固定の参照値** と比較する。CI で毎回実行し、変更による劣化を検出する。
- **シリアライズ**: 参照値は、信頼できるバージョンの実装で一度生成し、ファイルに保存しておく。テストではそれを読み込み、現在の実装の出力と比較する。

本格パイプラインを nvdiffrast に近づけるほど、テストとベンチマークの自動化が、品質維持と性能改善の両方に効きます。

---

## 16.7 まとめと次章への接続

- **メッシュ入力**: 頂点・面・UV・法線を統一フォーマットで受け、MVP と法線行列で変換。重複頂点（位置は同じで UV が異なる）の勾配マージを設計する。
- **バッチとマルチ解像度**: バッチ次元と解像度を API で切り替え、メモリと速度のトレードオフを意識する。
- **テクスチャ**: 補間 UV → 双線形サンプリング。PyTorch `grid_sample` または自作 CUDA。Mipmap は LOD 固定で勾配を流す。
- **アンチエイリアシング**: 解析的 AA を境界に組み込み、シルエット勾配と一貫させる。パフォーマンスは境界限定や解像度による切り替えで調整する。
- **半透明**: アルファ合成は式の上で微分可能。深度ソートと複数フラグメントの保持が必要で、コストとオプション化を検討する。
- **テストとベンチマーク**: nvdiffrast との出力・勾配の一致、速度・メモリの計測、CI でのレグレッション防止。

Part V はここまでで、実装編の「本格パイプライン」が一通り揃いました。  
次章（第 17 章、Part VI）では **nvdiffrast の解剖** に入り、アーキテクチャと API（rasterize と interpolate の分離）、カーネル構成、勾配の数式とコードの対応、エッジケース、トポロジー最適化、そして OpenGL/CUDA の相互運用を学びます。自作と nvdiffrast を並べて理解することで、nvdiffrast 相当の品質と設計に近づけます。

---

*前: [第 15 章 GPU 実装の基礎](Chapter15.md) | 次: [第 17 章 nvdiffrast の解剖](../Part06/Chapter17.md)*
