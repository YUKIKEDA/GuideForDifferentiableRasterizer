# 第20章 段階的演習

Part VIII では **演習とプロジェクト** で手を動かします。本章では **段階的演習** を 6 つ用意し、固定三角形の CPU ラスタライザ（20.1）から始め、ソフトラスタライザでの形状最適化（20.2）、解析的勾配の導出と実装（20.3）、簡単な GPU カーネル（20.4）、ミニ nvdiffrast の設計と実装（20.5）、そしてデバッグ演習（20.6）まで、本教材の内容を実装で確認できるようにします。各演習は対応する章を参照しつつ、目標・手順・確認ポイントを明示します。

---

## 20.1 演習 1: 固定三角形の CPU ラスタライザ

### 目標

第 13 章の「最小構成の CPU 実装」に沿い、**1 つの三角形** を **固定のスクリーン座標** でラスタライズし、エッジ関数と重心座標でピクセル色を補間してフレームバッファに書き込むプログラムを書く。

### 手順

1. **入力**: 3 頂点の 2D スクリーン座標 $(x_0, y_0), (x_1, y_1), (x_2, y_2)$ と、各頂点の色 $(R, G, B)$。解像度 $W \times H$。
2. **エッジ関数**: $E_{01}, E_{12}, E_{20}$ を第 6 章 6.2 の式で実装する。符号付き面積 $2A = E_{12}(\mathbf{p}_0)$ を計算し、$|2A| < \varepsilon$ なら退化としてスキップする。
3. **ループ**: 各ピクセル $(i, j)$ の中心 $(i+0.5, j+0.5)$ について、$E_{01}, E_{12}, E_{20} \ge 0$ なら内側とする。内側なら $u = E_{20}/(2A)$, $v = E_{01}/(2A)$ で重心座標を計算し、色を $C = (1-u-v)C_0 + u C_1 + v C_2$ で補間してフレームバッファに書き込む。
4. **出力**: 画像をファイルに保存（例: PNG）し、三角形が正しく塗られていることを目視で確認する。

### 確認ポイント

- 三角形の内側のピクセルのみ色が付き、外側は背景色（例: 黒）のままである。
- 頂点色が補間されて、グラデーションのように見える。
- 頂点の並び順（反時計回り）を逆にすると、面積 $2A$ の符号が変わり、内外判定が反転することを確認する（必要なら背面カリングの理解に繋げる）。

### 参照

第 6 章 6.2–6.3、第 13 章 13.2–13.3。

---

## 20.2 演習 2: ソフトラスタライザで形状を最適化

### 目標

第 10 章のソフトラスタライゼーションを実装し、**単純な形状**（例: 三角形の頂点位置）を、目標シルエットや目標画像に近づくように **勾配で最適化** する。

### 手順

1. **順伝播**: 頂点位置（2D または 3D→2D 射影）と頂点色を入力に、ピクセルごとに全三角形の「内側っぽさ」$m_t$（シグモイドで連続化）と深度のソフトマックス重み $w_t$ を計算し、色を $C = \sum_t w_t c_t$ で合成する（第 10 章 10.3）。
2. **逆伝播**: PyTorch の自動微分、または手で $w_t$ と $c_t$ の頂点位置に関する勾配を計算する。`loss.backward()` で頂点の `grad` を取得する。
3. **最適化ループ**: 目標画像または目標マスクとの L2 損失を定義し、オプティマイザ（SGD や Adam）で頂点位置を更新する。温度パラメータ $\tau$ は初期は大きめにし、必要ならアニーリングする。
4. **可視化**: イテレーションごとにレンダリング結果を保存し、形状が目標に近づくか確認する。

### 確認ポイント

- 損失が減少する。
- シルエットが目標マスクに近づく（または目標画像に近づく）。
- 温度 $\tau$ を変えたとき、境界のシャープさと勾配の安定性のトレードオフを体感する。

### 参照

第 10 章、第 14 章 14.1、第 19 章 19.2。

---

## 20.3 演習 3: 解析的勾配の導出と実装

### 目標

第 6 章・第 11 章の式に基づき、**見えている三角形についてだけ** 補間式の微分と重心座標の頂点に関する微分を実装し、**解析的勾配** で頂点位置への逆伝播を行う。

### 手順

1. **順伝播**: 通常のラスタライゼーション（1 三角形 per ピクセル）で、幾何バッファ（三角形 ID、重心座標 $(u,v)$、$1/w$ など）を保存する。
2. **補間の backward**: 上流から $\partial L/\partial C$ が渡されたとき、第 6 章 6.6.3 に従い $\partial L/\partial u$, $\partial L/\partial v$ および属性・$w$ への勾配を計算する。
3. **重心座標の backward**: 第 6 章 6.3.2 の式で、$(u,v)$ の頂点スクリーン座標に関する偏微分を実装する。スクリーン座標からクリップ座標へは、第 6 章 6.6.2 の $w$ 除算の backward でつなぐ。
4. **勾配チェック**: 1 頂点の 1 成分を perturb して数値勾配を計算し、解析的勾配と比較する（第 13 章 13.4.3、第 14 章 14.4.1）。相対誤差が十分小さいことを確認する。

### 確認ポイント

- 内部ピクセルでは、解析的勾配と数値勾配が一致する（離散切り替えのない範囲で）。
- 境界付近では、シルエット勾配を入れないとずれることがあることを認識する（演習 5 で境界を扱う）。

### 参照

第 6 章 6.3–6.6、第 11 章 11.4、第 14 章 14.2。

---

## 20.4 演習 4: 簡単な GPU カーネル

### 目標

第 15 章を踏まえ、**CUDA**（または Metal）で、ラスタライザの一部を GPU カーネルとして実装する。まずは「全ピクセルで同じ計算をする」ような単純なカーネル（例: 補間された色をフレームバッファに書き込む）でよい。

### 手順

1. **環境**: CUDA ツールキットと PyTorch（CUDA 対応）を用意する。`torch.cuda.is_available()` で確認する。
2. **最小カーネル**: 例として、既に CPU で求めた「ピクセルごとの色」を GPU に転送し、CUDA カーネルで「何か 1 つ変換してから」フレームバッファに書き込む（例: ガンマ補正）。`kernel<<<grid, block>>>(ptr)` で起動し、`ptr` は PyTorch テンソルの `.data_ptr()` から得る。
3. **PyTorch との連携**: `torch.utils.cpp_extension.load_inline` で CUDA を JIT コンパイルするか、`setup.py` で拡張をビルドする（第 15 章 15.6）。forward で CPU または GPU のテンソルを入力に取り、カーネルを呼んだあとテンソルを返す。
4. **backward**: 今回は「色の書き込み」だけなら、上流の勾配をそのまま対応するテンソルに渡せばよい。のちに「ラスタライゼーション全体を GPU で」する演習 5 に繋げる。

### 確認ポイント

- GPU 上でカーネルが動き、結果が CPU 版と一致する（または意図した変換になっている）。
- PyTorch のテンソルと CUDA のポインタのデバイス・dtype が一致している。

### 参照

第 15 章 15.1–15.4、15.6。

---

## 20.5 演習 5: ミニ nvdiffrast の設計と実装

### 目標

第 17 章の nvdiffrast の設計を参考に、**rasterize** と **interpolate** を分離した **ミニ nvdiffrast** を設計・実装する。API は「rasterize(pos, tri, resolution) → rast」「interpolate(attr, rast) → image」の形を目指す。

### 手順

1. **rasterize**: 入力はクリップ空間の頂点 `pos` と面 `tri`。出力は幾何バッファ（各ピクセルに三角形 ID、$(u,v)$、深度または $1/w$）。内部では、三角形並列またはピクセル並列で深度テストを行い、手前の三角形の情報を書き込む。退化・背面のガードを入れる（第 12 章、第 17 章 17.5）。
2. **interpolate**: 入力は頂点属性 `attr` と `rast`。`rast` に記録された三角形と重心座標で属性を補間（透視補正）し、画像を返す。
3. **backward**: interpolate の backward で属性と $(u,v)$ への勾配を計算する。$(u,v)$ の勾配を rasterize の backward に渡し、頂点 `pos` への勾配を計算する（第 6 章・第 11 章）。境界ではシルエット勾配を加算する（最小実装では省略可）。
4. **テスト**: 同じ入力で nvdiffrast とミニ実装の出力（画像・勾配）を比較する（第 16 章 16.6）。座標系を揃える（第 19 章 19.8）。

### 確認ポイント

- rasterize を 1 回呼び、interpolate を色・法線など複数回呼んでも、同じ rast で一貫した結果になる。
- 勾配が nvdiffrast に近い（完全一致は環境次第だが、傾向が同じか）。

### 参照

第 14 章 14.5、第 16 章 16.6、第 17 章。

---

## 20.6 演習 6: デバッグ演習

### 目標

**意図的にバグを含むコード** を修正し、**勾配消失・爆発** への対処を体験する。デバッグの手順（勾配チェック、可視化、段階的切り分け）を身につける。

### 20.6.1 意図的にバグを含むコードの修正

**想定バグの例**（講師や教材が用意するか、自分で 1 つずつ入れて検証する）:

- **重心座標の分母**: $u = E_{20}/(2A)$ の $2A$ を間違えて別のエッジ関数にしている。→ 描画がおかしくなり、勾配チェックでずれる。
- **$w$ 除算の backward**: クリップ座標への勾配で、$w_c$ への寄与を忘れている。→ 頂点の $w$ 成分に勾配が流れず、透視の変化に反応しない。
- **勾配の加算**: 複数ピクセルから同じ頂点に勾配を渡すとき、上書きしてしまっている。→ 勾配が一部だけになり、数値勾配と一致しない。
- **座標系**: スクリーン座標の $y$ の向きを逆にしている。→ 画像が上下反転し、他ライブラリと比較すると一致しない。

**手順**: (1) 勾配チェックで「どの変数でずれているか」を特定する。(2) その変数に関わる式（第 6 章・第 11 章）をコードと照合する。(3) 可視化（勾配マップ、重心座標の可視化）で怪しい領域を絞る。(4) 修正後、再度勾配チェックと参照実装との比較を行う。

### 20.6.2 勾配消失・爆発への対処

**勾配消失**: 勾配が 0 に近く、パラメータがほとんど更新されない。

- **原因の例**: ある層で `.detach()` してしまっている、境界でシルエット勾配を入れていないため輪郭付近の頂点に勾配が届かない、学習率が小さすぎる。
- **対処**: 計算グラフが途切れていないか確認する。シルエット勾配やソフトな重みで境界に勾配を流す。学習率・オプティマイザを調整する。

**勾配爆発**: 勾配が非常に大きくなり、更新でパラメータが吹っ飛ぶ。

- **原因の例**: 除算の分母が非常に小さい、損失のスケールが大きい、反復で勾配が増幅される。
- **対処**: 勾配のクリッピング（ノルムで上限を設ける）。除算に eps を足す、損失のスケールを下げる。第 12 章 12.2、第 17 章 17.5.2 の数値安定性を適用する。

**手順**: 勾配のノルムやヒストグラムをログし、消失・爆発が起きている層や変数を特定する。該当箇所で detach の有無・除算・損失の定義を見直す。

### 確認ポイント

- バグを修正したあと、勾配チェックが通る。
- 勾配消失・爆発の原因を「仮説→検証」で切り分けられる。

### 参照

第 14 章 14.4、第 18 章 18.4、第 12 章 12.2、第 17 章 17.5。

---

## 20.7 まとめと次章への接続

- **演習 1**: CPU で固定三角形をラスタライズし、エッジ関数と重心座標を体感する。
- **演習 2**: ソフトラスタで形状を最適化し、勾配が「形を変える」ことを確認する。
- **演習 3**: 解析的勾配を式から実装し、勾配チェックで正しさを検証する。
- **演習 4**: 簡単な GPU カーネルと PyTorch の連携を経験する。
- **演習 5**: rasterize / interpolate 分離のミニ nvdiffrast を設計・実装し、参照実装と比較する。
- **演習 6**: バグ修正と勾配消失・爆発の対処を通じて、デバッグの流れを身につける。

次章（第 21 章）では **参考文献とリソース** をまとめ、OpenDR・Soft Rasterizer・DIB-R・nvdiffrast などの論文、オープンソース実装へのリンク、NeRF やニューラル BRDF などの関連トピックを紹介します。本教材の学習を深めるための道しるべです。

---

*前: [第 19 章 逆レンダリングと最適化](../Part07/Chapter19.md) | 次: [第 21 章 参考文献とリソース](Chapter21.md)*
